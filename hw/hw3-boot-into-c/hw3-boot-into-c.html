<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<TITLE>CS5460/6460 Operating Systems</TITLE>
<LINK HREF="./css/main.css" TYPE="text/css" REL="stylesheet">
<META NAME="Description" CONTENT="CS5460/6450 Operating Systems">
<META NAME="Keywords" CONTENT="Anton Burtsev, Burtsev, Anton, CS5460/6450">
<SCRIPT SRC="./scripts/image_switcher.js" LANGUAGE="JavaScript"></SCRIPT>
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
	<TABLE  ID="text" ALIGN="CENTER" WIDTH="600" BORDER="0" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD>
		<DIV ID="tech_nav">
			<A HREF="../../index.html">Home</A>
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="30" ALT="" BORDER="0"/>
		</DIV>
	</TD>
	</TR>	
	<TR>
	<TD COLSPAN="4" ALIGN="LEFT" BGCOLOR="#FFFFFF">


		<P>

<h1>Homework 4: Boot into C</h1>

<p>This assignment will teach you to build a minimal bootable code that boots
on real hardware into C. Technically, you can do this assignment on any
operating system that supports the Unix API and can run Qemu (CADE
machines, your laptop that runs Linux or Linux VM, and even MacOS, etc.).
<b>You don't need to set up xv6 for this assignment</b>, but <b>if you're running
on CADE you'll have to install QEMU</b>, see <a href="../xv6-setup.html">QEMU 
setup instructions</a>. Submit your programs
and the shell through Gradescope (see instructions at the bottom of this page). 

<p><b>NOTE: YOU CANNOT PUBLICLY RELEASE SOLUTIONS TO THIS HOMEWORK</b>. It's ok to show 
your work to your future employer as a private Git repo, however any public release is prohibited. 


For <b>Mac / OSX</b> users: the support of 32 bit applications is deprecated in
the latest version of your system. So if you already updated your system to
MacOS Catalina or have updated your XCode then we recommend you to do the
homework at the CADE machines.  


This assignment explains how to create a minimal x86 operating system kernel using
the Multiboot standard. In fact, it will just boot and print "Hello, world!" on
the screen, and then print "Hello from C!" on the serial line from the C
<tt>main()</tt> function. 

Most of this assignment is based on <a href="https://intermezzos.github.io/book/first-edition/multiboot-headers.html">intermezzOS project</a>.


<h2>Boot overview</h2>

When you turn on a computer, it loads the BIOS from some special flash memory.
The BIOS runs self test and initialization routines of the hardware, then it
looks for bootable devices. If it finds one, the control is transferred to its
bootloader, which is a small portion of executable code stored at the device's
beginning. The bootloader has to determine the location of the kernel image on
the device and load it into memory. It also needs to switch the CPU to the
so-called protected mode because x86 CPUs start in the very limited real mode
by default (to be compatible to programs from 1978).

We won't write a bootloader because that would be a complex project on its own
(we partially covered this in class since xv6 implements a simple boot loader 
with two files: <tt>bootasm.S</tt> and <tt>bootmain.c</tt>). Instead
we will use one of the many well-tested bootloaders out there to boot our
kernel from a CD-ROM. 

<h2>Multiboot headers</h2>

<p>Let's get going! The very first thing we're going to do is create a 'multiboot
header'. What's that, you ask? Well, to explain it, let's take a small step
back and talk about how a computer boots up.</p>

<p>One of the amazing and terrible things about the x86 architecture is that it's
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it's also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That's right, when your fancy new computer starts up, it thinks
it's an 8086 from 1976. And then, through a succession of steps, we transition
through more and more modern architectures until we end at the latest and
greatest.</p>

<p>The first mode is called 'real mode'. This is a 16 bit mode that the original
x86 chips used. The second is 'protected mode'. This 32 bit mode adds new
things on top of real mode. It's called 'protected' because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections that allow
us to exercise more control around such things as RAM. We'll talk more about
those details later.</p>

<p>The final mode is called 'long mode', and it's 64 bits. Since our OS will 
only enter 32bit mode we'll not touch 64bit 'long mode'.</p>
<!--
<blockquote>
<p><strong>By the way...</strong></p>

<p>Well, that's actually a lie: there are two. Initially, you're not in long mode,
you're in 'compatibility mode'. You see, when the industry was undergoing the
transition from 32 to 64 bits, there were two options: the first was Intel's
Itanium 64-bit architecture. It did away with all of the stuff I just told
you about. But that meant that programs had to be completely recompiled from
scratch for the new chips. Intel's big competitor, AMD, saw an opportunity
here, and released a new set of chips called amd64. These chips were backwards
compatible, and so you could run both 32 and 64 bit programs on them.
Itanium wasn't compelling enough to make the pain worth it, and so Intel released
new chips that were compatible with amd64. The resulting architecture was then
called x86_64, the one we're using today. The moral of the story? Intel tried
to save you from all of the stuff we're about to do, but they failed. So
we have to do it.</p>
</blockquote>

-->

<p>So that's the task ahead of us: make the jump up the ladder and get to
32bit mode. We can do it! Let's talk more details.</p>

<h2>Firmware and the BIOS</h2>

<p>So let's begin by turning the power to our computer on.</p>

<p>When we press the power button, a bunch of low-level initialization protocols 
are executed: Management Engine, BIOS, etc.</p>

<p>With the BIOS we're already in the land of software, but unlike software that
you may be used to writing, the BIOS comes bundled with its computer and is located in
<em>r</em>ead-<em>o</em>nly <em>m</em>emory (ROM). 

<p>One of the first things the BIOS does is run a 'POST' or <em>p</em>ower-<em>o</em>n <em>s</em>elf-<em>t</em>est
which checks for the availability and integrity of all the pieces of hardware that
the computer needs including the BIOS itself, CPU registers, RAM, etc. If you've
ever heard a computer beeping at you as it boots up, that's the POST reporting
its findings.</p>

<p>Assuming no problems are found, the BIOS starts the real booting process.</p>

<blockquote>
<p><strong>By the way...</strong></p>

<p>For a while now most commercial computer manufacturers have hidden their BIOS
booting process behind some sort of splash screen. It's usually possible to see the
BIOS' logs by pressing some collection of keys when your computer is starting up.</p>

<p>The BIOS also has a menu where you can see information about the computer
like CPU and memory specs and all the hardware the BIOS detected like hard drives
and CD and DVD drives. Typically this menu is accessed by pressing some other
weird collection of keyboard keys while the computer is attempting to boot.</p>
</blockquote>

<p>The BIOS automatically finds a 'bootable drive' by looking in certain
pre-determined places like the computer's hard drive and CD and DVD drives.
A drive is 'bootable' if it contains software that can finish the booting
process. In the BIOS menu you can usually change in what order the BIOS looks
for bootable drives or tell it to boot from a specific drive.</p>

<p>The BIOS knows it's found a bootable drive by looking at the first few kilobytes
of the drive and looking for some magical numbers set in that drive's
memory. This won't be the last time some magical numbers or hacky sounding things
are used on our way to building an OS. Such is life at such a low level...</p>

<p>When the BIOS has found its bootable drive, it loads part of the drive into
memory and transfers execution to it. With this process, we move away from what
comes dictated by the computer manufacturer and move ever closer to getting our
OS running.</p>

<h2>Bootloaders</h2>

<p>The part of our bootable drive that gets executed is called a 'bootloader',
since it loads things at boot time. The bootloader's job is to take our kernel,
put it into memory, and then transition control to it.</p>

<p>Some people start their operating systems journey by writing a bootloader. For example, 
in class we started by looking at the xv6 bootloader that is loaded by the BIOS at the 
<tt>0x7c00</tt> address. In this assignment we will not be doing that. 

<p>In the interest of actually getting around to implementing a kernel, instead, we'll
use an existing bootloader: GRUB.</p>

<h2>GRUB and Multiboot</h2>

<p>GRUB stands for '<em>gr</em>and <em>u</em>nified <em>b</em>ootloader', and it's a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>

<p>The way that we do this is through a 'header'. We'll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>

<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don't even need to know
anything about all of that old stuff. If you're curious about the kinds of
things you would have needed to know, put "A20 line" into your favorite search
engine, and get ready to cry yourself to sleep.</p>

<h2>Writing our own Multiboot header</h2>

<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It's code time for real! You can download the entire folder 
that contains skeletons for the homework files <a href="./src">here</a> or 
save it file by file. Inside your homework folder there is a
file called <code>multiboot_header.asm</code>. Open it in your favorite editor.
I use <code>vim</code>, but you should feel free to use anything you'd like.</p>

<pre>
$ vim multiboot_header.asm
</pre>

This is a <code>.asm</code> file, which is short for 'assembly'. That's right, we're
going to write some assembly code here. Don't worry! It's not super hard.</p>

<h3>An aside about assembly</h3>

<p>Have you ever watched Rich Hickey's talk "Simple vs. Easy"? It's a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms.</p>

<p>Assembly coding is simple, but that doesn't mean that it's easy. We'll be doing
a little bit of assembly programming to build our operating system, but we
don't need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You've got this. A good manual on NASM assembler 
is <a href="https://nasm.us/doc/nasmdoc3.html">here</a>.</p>

<h3>The Magic Number</h3>

<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here's the
first line:</p>

<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>

<p>Ugh! Gibberish! Let's start with the semicolon (<code>;</code>). It's a comment, that
lasts until the end of the line. This particular comment says 'magic number'.
As we said, you'll be seeing a lot of magic numbers in your operating system work.
The idea of a magic number is that it's completely and utterly arbitrary. It
doesn't mean anything. It's just magic. The very first thing that the multiboot
specification requires is that we have the magic number <code>0xe85250d6</code> right
at the start.</p>

<blockquote>
<p><strong>By the way...</strong></p>
<p>Wondering how a number can have letters inside of it? <code>0xe85250d6</code> is written in
hexadecimal notation. Hexadecimal is an example of a &quot;numeral system&quot; which is a
fancy term for a system for conveying numbers. The numeral system you're probably most
familiar with is the decimal system which conveys numbers using a combination of the
symbols <code>0</code> - <code>9</code>. Hexadecimal on the other hand uses a combination of 16 symbols:
<code>0</code> - <code>9</code> and <code>a</code> - <code>f</code>. Along with its fellow numeral system, binary, hexadecimal
is used <em>a lot</em> in low level programming. In order to tell if a number is written
in hexadecimal, you may be tempted to look for the use of letters in the number,
but a more surefire way is to look for a leading <code>0x</code>. While <code>100</code> isn't a hexadecimal
number, <code>0x100</code> is.</p>
</blockquote>

<p>What's the value in having an arbitrary number there? Well, it's a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn't have the magic number,
something has gone wrong, and we can throw an error.</p>

<p>I have no idea why it's <code>0xe85250d6</code>, and I don't need to care. It just is.</p>

<p>Finally, the <code>dd</code>. It's short for 'define double word'. It declares that we're
going to stick some 32-bit data at this location. Remember, when x86 first started,
it was a 16-bit architecture set. That meant that the amount of data that could be
held in a CPU register (or one 'word' as it's commonly known) was 16 bits.
To transition to a 32-bit architecture without losing backwards compatibility,
x86 got the concept of a 'double word' or double 16 bits.</p>

<h3>The mode code</a></h3>

<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>

<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>


<h3>Header length</h3>

<p>The next thing that's required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there's two reasons why
we're not doing that:</p>

<ol>
<li>Computers should do math, not people.</li>

<li>We're going to add more stuff, and we'd have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>

<p>Here's what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>

<p>You don't have to align the comments if you don't want to. I usually don't, but
it looks nice and after we're done with this file, we're not going to mess with
it again, so we won't be constantly re-aligning them in the future.</p>

<p>The <code>header_start:</code> and <code>header_end:</code> things are called 'labels'. Labels let
us use a name to refer to a particular part of our code. Labels also refer to the
memory occupied by the data and code which directly follows it. So in our code above
the label <code>header_start</code> points directly to the memory at the very beginning of our
magic number and thus to the very beginning of our header.</p>

<p>Our third <code>dd</code> line uses those two labels to do some math: the header length is
the value of <code>header_end</code> minus the value of <code>header_start</code>. Because <code>header_start</code>
and <code>header_end</code> are just the addresses of places in memory, we can simply subtract
to get the distance between those two addresses. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>

<p>You'll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it's a pretty flexible format.</p>

<h3>The Checksum</h3>

<p>The fourth field multiboot requires is a 'checksum'. The idea is that we sum up
some numbers, and then use that number to check that they're all what we
expected things to be. It's similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>

<p>Here's the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>

<p>Again, we'll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>

<blockquote>
<p><strong>By the way...</strong></p>

<p>You might wonder why we're subtracting these values from 0x100000000. To answer this we can look at what <a href="http://nongnu.askapache.com/grub/phcoder/multiboot.pdf">the multiboot spec</a> says about the checksum value in the header:</p>
<blockquote>

<p>The field <code>checksum</code> is a 32-bit <a href="http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">unsigned value</a> which, when added to the other magic fields (i.e. <code>magic</code>, <code>architecture</code> and <code>header_length</code>), must have a 32-bit unsigned sum of zero.</p>
</blockquote>

<p>In other words:</p>
<p><code>checksum</code> + <code>magic_number</code> + <code>architecture</code> + <code>header_length</code> = 0</p>

<p>We could try and &quot;solve for&quot; <code>checksum</code> like so:</p>

<p><code>checksum</code> =  -(<code>magic_number</code> + <code>architecture</code> + <code>header_length</code>)</p>

<p>But here's where it gets weird. Computers don't have an innate concept of negative numbers. Normally we get around this by using &quot;signed integers&quot;, which is something we <a href="http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">cover in an appendix</a>. The point is we have an unsigned integer here, which means we're limited to representing only positive numbers. This means we can't literally represent -(<code>magic_number</code> + <code>architecture</code> + <code>header_length</code>) in our field.</p>

<p>If you look closely at the spec you'll notice it's strangely worded: it's asking for a value that when added to other values has a sum of zero. It's worded this way because integers have a limit to the size of numbers they can represent, and when you go over that size, the values wrap back around to zero. So 0xFFFFFFFF + 1 is.... 0x00000000. This is a hardware limitation: technically it's doing the addition correctly, giving us the 33-bit value 0x100000000, but we only have 32 bits to store things in so it can't actually tell us about that <code>1</code> in the most significant digit position! We're left with the rest of the digits, which spell out zero.</p>

<p>So what we can do here is &quot;trick&quot; the computer into giving us zero when we do the addition. Imagine for the sake of argument that <code>magic_number</code> + <code>architecture</code> + <code>header_length</code> somehow works out to be 0xFFFFFFFE. The number we'd add to that in order to make 0 would be 0x00000002. This is 0x100000000-0xFFFFFFFE, because 0x100000000 technically maps to 0 when we wrap around. So we replace 0xFFFFFFFE in our contrived example here with <code>magic_number</code> + <code>architecture</code> + <code>header_length</code>. This gives us:
<code>dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))</code></p>
</blockquote>

<h3>Ending tag</h3>

<p>After the checksum you can list a series of "tags", which is a way for the OS to
tell the bootloader to do some extra things before handing control over to the
OS, or to give the OS some extra information once started. We don't need any of
that yet, though, so we just need to include the required "end tag", which looks
like this:</p>

<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>

<p>Here we use <code>dw</code> to define a 'word' instead of just data. Remember a 'word' is 16
bits or 2 bytes on the x86_64 architecture. The multiboot specification demands
that this be exactly a word. You'll find that this is super common in operating systems:
the exact size and amount of everything matters. It's just a side-effect of
working at a low level.</p>

<h3>The Section</h3>

<p>We have one last thing to do: add a 'section' annotation. We'll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>

<p>Here's the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>

<p>That's it! Congrats, you've written a multiboot compliant header. It's a lot of
esoterica, but it's pretty straightforward once you've seen it a few times.</p>

<h2>Assembling with <code>nasm</code></h2>

<p>We can't use this file directly, we need to turn it into binary. We can use a
program called an 'assembler' to 'assemble' our assembly code into binary code.
It's very similar to using a 'compiler' to 'compile' our source code into
binary. But when it's assembly, people often use the more specific name.</p>

<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>

<pre><code class="language-bash">$ nasm -f elf32 multiboot_header.asm
</code></pre>

<p>The <code>-f elf32</code> says that we want to output a file as 32bit ELF. 

<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our 'object file', hence the <code>.o</code>. Don't let the
word 'object' confuse you. It has nothing to do with anything object oriented.
'Object files' are just binary code with some metadata in a particular format -
in our case ELF. Later, we'll take this file and use it to build our OS.</p>

You can inspect the bytes of the header with <code>hexdump</code>(depending on the environment the address may be different but the following content should be somewhere in the ouput)
<pre>
&gt; hexdump -x multiboot_header.o
0000000    50d6    e852    0000    0000    0018    0000    af12    17ad
0000010    0000    0000    0008    0000
0000018
</pre>

<h2>Summary</h2>

<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we'll write the actual code that prints "Hello world" to the screen.</p>

<h1>Hello, world!</h1>

<p>Now that we've got the headers out of the way, let's do the traditional first
program: Hello, world!</p>

<h2>The smallest kernel</h2>

<p>Our hello world will be just <em>20</em> lines of assembly code. Let's begin.

Open a file called <code>boot.asm</code> and put this in it:</p>
<pre><code class="language-x86asm">start:
    hlt
</code></pre>

<p>You've seen the <code>name:</code> form before: it's a <em>label</em>. This lets us name a line
of code. We'll call this label <code>start</code>, which is the traditional name.
GRUB will use this convention to know where to begin.</p>

<p>The <code>hlt</code> statement is our first bit of 'real' assembly. So far, we had just
been declaring data. This is actual, executable code. It's short for 'halt'.
In other words, it ends the program.</p>

<p>By giving this line a label, we can call it, sort of like a function. That's what
GRUB does: "Call the function named <code>start</code>." This function has just one
line: stop.</p>

<p>Unlike many other languages, you'll notice that there's no way to say if
this 'function' takes any arguments or not. We'll talk more about that later.</p>

<p>This code won't quite work on its own though. We need to do a little bit more
bookkeeping first. Here's the next few lines:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    hlt
</code></pre>

<p>Three new bits of information. The first:</p>
<pre><code class="language-x86asm">global start
</code></pre>

<p>This says "I'm going to define a label <code>start</code>, and I want it to be available
outside of this file." If we don't say this, GRUB won't know where to find its
definition. You can kind of think of it like a 'public' annotation in other
languages.</p>

<pre><code class="language-x86asm">section .text
</code></pre>

<p>We saw <code>section</code> briefly, but I told you we'd get to it later. The place where
we get to it is at the end of this chapter. For the moment, all you need to
know is this: code goes into a section named <code>.text</code>. Everything that comes
after the <code>section</code> line is in that section, until another <code>section</code> line.</p>
<pre><code class="language-x86asm">bits 32
</code></pre>

<p>GRUB will boot us into protected mode, aka 32-bit mode (similar to how xv6 bootloader
starts in 16bit real mode GRUB will be loaded by the BIOS and will switch into protected 32bit 
mode for us). But we have to specify directly that assembler has to generate 32bit code. 
Our Hello World will only be in 32 bits.</p>

<p>That's it! We could theoretically stop here, but instead, let's actually print
the "Hello world" text to the screen. We'll start off with an 'H':</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    hlt
</code></pre>

<p>This new line is the most complicated bit of assembly we've seen yet. There's a
lot packed into this little line.</p>

<p>The first important bit is <code>mov</code>. This is short for <code>move</code>, and it sorta looks
like this:</p>
<pre><code class="language-text">mov size place, thing
</code></pre>

<p>Oh, <code>;</code> starts a comment, remember? So the <code>; H</code> is just for us. I put this
comment here because this line prints an <code>H</code> to the screen!</p>

<p>Yup, it does. Okay, so here's why: <code>mov</code> copies <code>thing</code> into <code>place</code>. The amount
of stuff it copies is determined by <code>size</code>.</p>
<pre><code class="language-x86asm">;   size place      thing
;   |    |          |
;   V    V          V
mov word [0xb8000], 0x0248 ; H
</code></pre>

<p>"Copy one word: the number <code>0x0248</code> to ... some place.</p>

<p>The <code>place</code> looks like a number just like <code>0x0248</code>, but it has square 
brackets <code>[]</code> around it. Those brackets are special. They mean "the address 
in memory located by this number." In other words, we're copying the number 
<code>0x0248</code> into the specific memory location <code>0xb8000</code>. That's what this line does.</p>

<p>Why? Well, we're using the screen as a "memory mapped" device. Specific
positions in memory correspond to certain positions on the screen. And
the position <code>0xb8000</code> is one of those positions: the upper-left corner of the
screen.</p>

<blockquote>

<p><strong>By the way...</strong></p>

<p>&quot;Memory mapping&quot; is one of the fundamental techniques used in computer
engineering to help the CPU know how to talk to all the different physical
components of a computer. The CPU itself is just a weird little machine that
moves numbers around. It's not of any use to humans on its own: it needs to be
connected to devices like RAM, hard drives, a monitor, and a keyboard. The way
the CPU does this is through a <em>bus</em>, which is a huge pipeline of wires
connecting the CPU to every single device that might have data the CPU needs.
There's one wire per bit (since a wire can store a 1 or a 0 at any given time).
A 32-bit bus is literally 32 wires in parallel that run from the CPU to a bunch
of devices like Christmas lights around a house.</p>

<p>There are two buses that we really care about in a computer: the address bus
and the data bus. There's also a third signal that lets all the devices know
whether the CPU is requesting data from an input (reading, like from the
keyboard) or sending data to an output (writing, like to the monitor via the
video card). The address bus is for the CPU to send location information, and
the data bus is for the CPU to either write data to or read data from that
location.  Every device on the computer has a unique hard coded numerical
location, or &quot;address&quot;, literally determined by how the thing is wired up at
the factory. In the case of an input/read operation, when it sends <code>0x1001A003</code>
out on the address bus and the control signal notifies every device that it's a
read operation, it's asking, &quot;What is the data currently stored at location
<code>0x1001A003</code>?&quot; If the keyboard happens to be identified by that particular
address, and the user is pressing SPACE at this time, the keyboard says, &quot;Oh,
you're talking to me!&quot; and sends back the ASCII code <code>0x00000020</code> (for &quot;SPACE&quot;)
on the data bus.</p>

<p>What this means is that memory on a computer isn't just representing things like
RAM and your hard drive. Actual human-scale devices like the keyboard and mouse
and video card have their own memory locations too. But instead of writing a byte
to a hard drive for storage, the CPU might write a byte representing some color
and symbol to the monitor for display. There's an industry standard somewhere
that says video memory must live in the address range beginning <code>0xb8000</code>. In
order for computers to be able to work out of the box, this means that the BIOS
needs to be manufactured to assume video lives at that location, and the
motherboard (which is where the bus is all wired up) has to be manufactured to
route a <code>0xb8000</code> request to the video card.  It's kind of amazing this stuff
works at all! Anyway, &quot;memory mapped hardware&quot;, or &quot;memory mapping&quot; for short,
is the name of this technique.</p>
</blockquote>

<p>Now, we are copying <code>0x0248</code>. Why this number? Well, it's in three parts:</p>
<pre><code class="language-text"> __ background color
/  __foreground color
| /
V V
0 2 48 &lt;- letter, in ASCII
</code></pre>
<p>We'll start at the right. First, two numbers are the letter, in ASCII. <code>H</code> is
72 in ASCII, and 48 is 72 in hexadecimal: <code>(4 * 16) + 8 = 72</code>. So this will
write <code>H</code>.</p>
<p>The other two numbers are colors. There are 16 colors available, each with a
number. Here's the table:</p>
<pre><code class="language-text">| Value | Color          |
|-------|----------------|
| 0x0   | black          |
| 0x1   | blue           |
| 0x2   | green          |
| 0x3   | cyan           |
| 0x4   | red            |
| 0x5   | magenta        |
| 0x6   | brown          |
| 0x7   | gray           |
| 0x8   | dark gray      |
| 0x9   | bright blue    |
| 0xA   | bright green   |
| 0xB   | bright cyan    |
| 0xC   | bright red     |
| 0xD   | bright magenta |
| 0xE   | yellow         |
| 0xF   | white          |
</code></pre>

<p>So, <code>02</code> is a black background with a green foreground. Classic. Feel free to
change this up, use whatever combination of colors you want!</p>
<p>So this gives us a <code>H</code> in green, over black. Next letter: <code>e</code>.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    hlt
</code></pre>

<p>Lower case <code>e</code> is <code>65</code> in ASCII, at least, in hexadecimal. And <code>02</code> is our same
color code. But you'll notice that the memory location is different.</p>
<p>Okay, so we copied four hexadecimal digits into memory, right? For our <code>H</code>.
<code>0248</code>. A hexadecimal digit has sixteen values, which is 4 bits (for example, <code>0xf</code>
would be represented in bits as <code>1111</code>). Two of them make 8 bits, i.e. one byte.
Since we need half a word for the colors (<code>02</code>), and half a word for the <code>H</code> (<code>48</code>),
that's one word in total (or two bytes). Each place that the memory address points
to can hold one byte (a.k.a. 8 bits or half a word). Hence, if our first memory
position is at <code>0</code>, the second letter will start at <code>2</code>.</p>

<blockquote>

<p>You might be wondering, &quot;If we're in 32 bit mode, isn't a word 32 bits?&quot; since sometimes 'word' is used to talk about native CPU register size. Well, the 'word' keyword in the context of x86_64 assembly specifically refers to 2 bytes, or 16 bits of data.  This is for reasons of backwards compatibility.</p>
</blockquote>

<p>This math gets easier the more often you do it. And we won't be doing <em>that</em> much
more of it. There is a lot of working with hex numbers in operating systems work,
so you'll get better as we practice.</p>

<p>With this, you should be able to get the rest of Hello, World. Go ahead and try
if you want: each letter needs to bump the location twice, and you need to look
up the letter's number in hex.</p>

<p>If you don't want to bother with all that, here's the final code:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    mov word [0xb8004], 0x026c ; l
    mov word [0xb8006], 0x026c ; l
    mov word [0xb8008], 0x026f ; o
    mov word [0xb800a], 0x022c ; ,
    mov word [0xb800c], 0x0220 ;
    mov word [0xb800e], 0x0277 ; w
    mov word [0xb8010], 0x026f ; o
    mov word [0xb8012], 0x0272 ; r
    mov word [0xb8014], 0x026c ; l
    mov word [0xb8016], 0x0264 ; d
    mov word [0xb8018], 0x0221 ; !
    hlt
</code></pre>

<p>Finally, now that we've got all of the code working, we can assemble our
<code>boot.asm</code> file with <code>nasm</code>, just like we did with the <code>multiboot_header.asm</code>
file:</p>

<pre><code class="language-bash">$ nasm -f elf32 boot.asm
</code></pre>

<p>This will produce a <code>boot.o</code> file. We're almost ready to go!</p>

<h2>Linking it together</h2>

<p>Okay! So we have two different <code>.o</code> files: <code>multiboot_header.o</code> and <code>boot.o</code>.
But what we need is <em>one</em> file with both of them. Our OS doesn't have the
ability to do anything yet, let alone load itself in two parts somehow. We just
want one big binary file.</p>

<p>Enter 'linking'. If you haven't worked in a compiled language before, you
probably haven't had to deal with linking before. Linking is how we'll turn
these two files into a single output: by linking them together.</p>

<p>Open up a file called <code>linker.ld</code>and put this in it:</p>

<pre><code class="language-text">
ENTRY(start)
  
SECTIONS {
  . = 0x100000; /* Tells GRUB to load the kernel starting at the 1MB mark */

  .rodata :
  {
    /* ensure that the multiboot header is at the beginning */
    KEEP(*(.multiboot_header))
    *(.rodata .rodata.*) 
    . = ALIGN(4K);
  }

  .text :
  { 
    *(.text .text.*)
    . = ALIGN(4K);
  } 
    
  .data :
  { 
    *(.data .data.*)
    . = ALIGN(4K);
  }   
    
  .bss :
  {   
    *(.bss .bss.*)
    . = ALIGN(4K);
  }     
} 
</code></pre>

<p>This is a 'linker script'. It controls how our linker will combine these
files into the final output. Let's take it bit-by-bit:</p>

<pre><code class="language-text">ENTRY(start)
</code></pre>

<p>This sets the 'entry point' for this executable. In our case, we called our
entry point by the name people use: <code>start</code>. Remember? In <code>boot.asm</code>? Same
name here.</p>

<pre><code class="language-text">SECTIONS {
</code></pre>

<p>Okay! I've been promising you that we'd talk about sections. Everything inside
of these curly braces is a section. We annotated parts of our code with
sections earlier, and here, in this part of the linker script, we will describe
each section by name and where it goes in the resulting output.</p>

<pre><code class="language-text">
. = 0x100000;
</code></pre>

<p>This line means that we will start putting sections at the one megabyte mark.
This is the conventional place to put a kernel, at least to start. Below one
megabyte is all kinds of memory-mapped stuff. Remember the VGA stuff? It
wouldn't work if we mapped our kernel's code to that part of memory... garbage
on the screen!</p>

<pre><code class="language-text">
.rodata :
</code></pre>

<p>This will create a section named <code>rodata</code>. And inside of it...</p>

<pre><code class="language-text">
*(.multiboot_header)
</code></pre>

<p>... goes every section named <code>multiboot_header</code>. Remember how we defined that
section in <code>multiboot_header.asm</code>? It'll be here, at the start of the <code>boot</code>
section. That's what we need for GRUB to see it.</p>

<pre><code class="language-text">
.text :
</code></pre>

<p>Next, we define a <code>text</code> section. The <code>text</code> section is where you put code.
And inside of it...</p>

<pre><code class="language-text">
*(.text)
</code></pre>

<p>... goes every section named <code>.text</code>. See how this is working? The syntax is a
bit weird, but it's not too bad.</p>

<p>We do the same for the <code>code</code> and <code>bss</code> section. 

<p>That's it for our script! We can then use <code>ld</code> to link all of this stuff
together:</p>



<pre><code class="language-bash">$ ld -m elf_i386 -T linker.ld -o kernel.bin multiboot_header.o boot.o
</code></pre>

<p>Recall that on Mac OS X you will want to use the linker we installed to
<code>~/opt</code> and not your system linker. For example, if you did not change any of
the defaults in the installation script, this linker will be located at
<code>$HOME/opt/bin/x86_64-pc-elf-ld</code>.</p>

<p>By running this command, we do a few things:</p>
<pre><code class="language-text">
-m elf_i386
</code></pre>

ask the linker to generate the 32bit.

<pre><code class="language-text">-T linker.ld
</code></pre>

<p>This is the linker script we just made, we ask the linker to use it.</p>

<pre><code class="language-text">-o kernel.bin
</code></pre>

<p>This sets the name of our output file. In our case, that's <code>kernel.bin</code>. We'll be using
this file in the next step. It's our whole kernel!</p>

<pre><code class="language-text">multiboot_header.o boot.o
</code></pre>

<p>Finally, we pass all the <code>.o</code> files we want to link together.</p>

<p>That's it! We've now got our kernel in the <code>kernel.bin</code> file. Next, we're going to
make an ISO out of it, so that we can load it up in QEMU.</p>

<h1>Making an ISO</h1>

<p>Now that we have our <code>kernel.bin</code>, the next step is to make an ISO. Remember
compact discs? Well, by making an ISO file, we can both test our Hello World
kernel in QEMU, as well as running it on actual hardware!</p>

<p>To do this, we're going to use a GRUB tool called <code>grub2-mkrescue</code>. We have to
create a certain structure of files on disk, run the tool, and we'll get an
<code>hello.iso</code> file at the end.</p>

<p>Doing so is not very much work, but we need to make the files in the right
places. First, we need to make several directories:</p>

<pre><code class="language-bash">$ mkdir -p build/isofiles/boot/grub
</code></pre>

<p>The <code>-p</code> flag to <code>mkdir</code> will make the directory we specify, as well as any
'parent' directories, hence the <code>p</code>. In other words, this will make an
<code>build</code> directory with a <code>isofiles</code> directory inside that has <code>boot</code> inside, and finally the <code>grub</code> directory
inside of that.</p>

<p>Next, create the <code>grub.cfg</code> file inside of that <code>build/isofiles/boot/grub</code> directory,
and put this in it:</p>

<pre><code class="language-text">set timeout=0
set default=0

menuentry &quot;cs5460os&quot; {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre>

<p>This file configures GRUB. Let's talk about the <code>menuentry</code> block first.
GRUB lets us load up multiple different operating systems, and it usually does
this by displaying a menu of OS choices to the user when the machine boots. Each
<code>menuentry</code> section corresponds to one of these. We give it a name, in this
case, <code>cs5460os</code>, and then a little script to tell it what to do. First,
we use the <code>multiboot2</code> command to point at our kernel file. In this case,
that location is <code>/boot/kernel.bin</code>. Remember how we made a <code>boot</code> directory
inside of <code>isofiles</code>? Since we're making the ISO out of the <code>isofiles</code> directory,
everything inside of it is at the root of our ISO. Hence <code>/boot</code>.</p>

<p>Let's copy our <code>kernel.bin</code> file there now:</p>

<pre><code class="language-bash">$ cp kernel.bin build/isofiles/boot/
</code></pre>

<p>Finally, the <code>boot</code> command says "that's all the configuration we need to do,
boot it up."</p>

<p>But what about those <code>timeout</code> and <code>default</code> settings? Well, the <code>default</code> setting
controls which <code>menuentry</code> we want to be the default. The numbers start at zero,
and since we only have that one, we set it as the default. When GRUB starts, it
will wait for <code>timeout</code> seconds, and then choose the <code>default</code> option if the user
didn't pick a different one. Since we only have one option here, we just set it to
zero, so it will start up right away.</p>

<p>The final layout should look like this:</p>
<pre><code class="language-text">
build/
|---isofiles/
    |---boot
        |-- grub
        |   |-- grub.cfg
        |-- kernel.bin
</code></pre>

<p>Using <code>grub2-mkrescue</code> is easy. We run this command:</p>
<pre><code class="language-bash">$ grub2-mkrescue -o hello.iso build/isofiles
</code></pre>

<p>The <code>-o</code> flag controls the <em>o</em>utput filename, which we choose to be <code>hello.iso</code>.
And then we pass it the directory to make the ISO out of, which is the
<code>build/isofiles</code> directory we just set up.</p>

<p>Note, if you're on a CADE machine, likely you don't have the GRUB <code>i386</code> 
module (we have no control over cade unfortunately, but that's ok). We have a fix:
use the <code>wget</code> command to download the <a href="./gr.zip">i386 module</a> 
to the project directory and unzip it. Like this: 

<pre><code class="language-text">wget https://users.cs.utah.edu/~aburtsev/5460/hw/hw3-boot-into-c/gr.zip
unzip gr.zip
</code></pre> 

You then need to add the following option <code>-d lib/grub/i386-pc</code> (to use the <code>i386</code>) 
to the <code>grub2-mkrescue</code> command.

<pre><code class="language-bash">$ grub2-mkrescue -d lib/grub/i386-pc -o hello.iso build/isofiles
</code></pre>

<p>After this, you have an <code>hello.iso</code> file with our teeny kernel on it. You could
burn this to a USB stick or CD and run it on an actual computer if you wanted
to! But doing so would be really annoying during development. So in the next
section, we'll use an emulator, QEMU, to run the ISO file on our development
machine.</p>
       

 <h2>Troubleshooting GRUB issues</h2>
        <ul>
            <li>There is a chance you might encounter the following issue: 
                <pre><code>grub-mkrescue: error: xorriso not found</code></pre>
                Solution: if on your own machine, install <code>xorriso</code>. If on CADE, wget the <a href="./xorriso">xorriso</a> binary, run <code>chmod +x xorriso</code> and add it the your <code>$PATH</code>. For example, if you are using <code>bash</code> and the <code>xorriso</code> binary is in <code>~/bin</code>,
                append <code>export PATH=$HOME/bin:$PATH</code> to your <code>.bashrc</code>.
            </li>
        </ul>


<h1>Running in QEMU</h1>

<p>Let's actually run our kernel! To do this, we'll use <a
	href="http://www.qemu.org/">QEMU</a>, a full-system emulator. Using
QEMU is fairly straightfoward. 


<p>If you're running on CADE inside an ssh terminal
you don't have a GUI interface, hence we need to use <code>-curses</code>,
Curses is a library that is designed to facilitate GUI-like functionality on a
text-only device (see a <a href="https://en.wikipedia.org/wiki/Curses_(programming_library)">wiki page</a>):</p>

<pre><code class="language-bash">$ qemu-system-x86_64 -curses -cdrom hello.iso
</code></pre>

<p>Type it in, hit Enter, and you should see <code>Hello, world!</code> (To exit, hit
<kbd>Esc+2</kbd> and type <code>quit</code> in the console.)</p>

<p>If you're running on your own machine with a GUI terminal you can simply run:</p>

<pre><code class="language-bash">$ qemu-system-x86_64 -cdrom hello.iso
</code></pre>

<p>You should see something what really looks like a screen of the computer with <code>Hello, world!</code> (To exit, hit
<kbd>Alt+2</kbd> and type <code>quit</code> in the console.)</p>

<p>If it shows up for you too, congrats! If not, something may have gone
wrong. Double check that you followed the examples <em>exactly</em>. Maybe
you missed something, or made a mistake while copying things down.</p>

<p>Note all of this other stuff behind the Hello World message: this part may look
different, based on your version of GRUB, and also since we didn't clear the
screen, everything from GRUB just stays as it is. We'll write a function to do
that eventually...</p>

<p>Let's talk about this command before we move on:</p>
<pre><code class="language-text">qemu-system-x86_64
</code></pre>

<p>We're running the <code>x86_64</code> variant of QEMU. While we have a 32-bit kernel 
the QEMU emulates x86 64bit architecture. And since 32bit code is part of it everything 
works.</p>

<pre><code class="language-text">-cdrom hello.iso
</code></pre>

<p>We're going to start QEMU with a CD-ROM drive, and its contents are the
<code>hello.iso</code> file we made.</p>

<p>That's it! Here's the thing, though: while that wasn't <em>too</em> complicated, it
was a lot of steps. Each time we make a change, we have to go through all these
steps over again. In the next section, we'll use Make to do all these steps for
us.</p>


 <h2>Troubleshooting GRUB issues</h2>
        <ul>
            <li>Again, if you see the following error on the screen:
                <pre><code>Boot failed: Could not read from CDROM (code 0004)</code></pre>
                <p>See the <code>i386</code> module issue on CADE above.
            </li>
        </ul>



<h1>Automation with Make</h1>

<p>Typing all of these commands out every time we want to build the project is
tiring and error-prone. It's nice to be able to have a single command that
builds our entire project. To do this, we'll use <code>make</code>. Download
this <a href="./src/Makefile">Makefile</a> and look over it.</p>

<p>To make this Makefile working move create boot folder in the same directory as Makefile and put previously created grub.cfg into boot folder.</p>

<p>The makefile starts by defining several variables <code>kernel</code>,
 <code>iso</code>, <code>linker_script</code>, and <code>grub_cfg</code> that
define names of the output files we want to make. <code>CFLAGS</code> is a variable 
that defines all flags to the GCC compiler. 

<pre>
kernel := build/kernel.bin
iso := build/hello.iso

linker_script := linker.ld
grub_cfg := boot/grub.cfg

CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O1 -Wall -MD -ggdb -m32 -fno-omit-frame-pointer -Werror -nostdlib

target ?= hello
</pre>

<p>We then create two lists: a list of assembly files in the folder <code>assembly_source_files</code> 
and a list of C source files, <code>c_source_files</code>. We then use the <code>patsubst</code>
command to generate another two lists that are the same file names but with <code>.o</code> as 
extension:  
<pre>
assembly_source_files := $(wildcard *.asm)
assembly_object_files := $(patsubst %.asm, build/%.o, $(assembly_source_files))
c_source_files := $(wildcard *.c)
c_object_files := $(patsubst %.c, build/%.o, $(c_source_files))
</pre>

<pre>
.PHONY: all clean qemu qemu-nox qemu-gdb qemu-gdb-nox 

all: $(kernel)

clean:
        rm -rf build

qemu: $(iso)
        qemu-system-x86_64 -cdrom $(iso) -vga std -s -serial file:serial.log

qemu-nox: $(iso)
        qemu-system-x86_64 -m 128 -cdrom $(iso) -vga std -s -no-reboot -nographic 

qemu-gdb: $(iso)
        qemu-system-x86_64 -S -m 128 -cdrom $(iso) -vga std -s -serial file:serial.log -no-reboot -no-shutdown -d int,cpu_reset 

.PHONY: qemu-gdb-nox
qemu-gdb-nox: $(iso)
        qemu-system-x86_64 -S -m 128 -cdrom $(iso) -vga std -s -serial file:serial.log -no-reboot -no-shutdown -d int,cpu_reset -nographic

iso: $(iso)
        @echo "Done"

$(iso): $(kernel) $(grub_cfg)
        @mkdir -p build/isofiles/boot/grub
        cp $(kernel) build/isofiles/boot/kernel.bin
        cp $(grub_cfg) build/isofiles/boot/grub
        grub2-mkrescue -o $(iso) build/isofiles #2> /dev/null
        @rm -r build/isofiles

$(kernel): $(c_object_files) $(assembly_object_files) $(linker_script)
        ld -m elf_i386  -T $(linker_script) -o $(kernel) $(assembly_object_files) $(c_object_files)

# compile C files
build/%.o: %.c
        @mkdir -p $(shell dirname $@)
        gcc $(CFLAGS) -c $< -o $@

# compile assembly files
build/%.o: %.asm
        @mkdir -p $(shell dirname $@)
        nasm -felf32 $< -o $@
</pre>

<p>Our default 
action is <code>all</code> (it will build the kernel by invoking the linker). Of course 
before linking the kernel, all object files have to be compiled. 

<p>Also it's nice to add targets which describe a specific actions. 
To run the kernel we add a rule</p>
<pre>
qemu: $(iso)
        qemu-system-x86_64 -cdrom $(iso) -vga std -s -serial file:serial.log
</code></pre>

<p>Finally, there's another useful common rule: <code>clean</code>. The <code>clean</code> rule should remove all
of the generated files, and allow us to do a full re-build. 

<p>Now there's just one more wrinkle. We have four targets that aren't really files
on disk, they are just actions: <code>default</code>, <code>build</code>, <code>run</code> and <code>clean</code>. Remember
we said earlier that <code>make</code> decides whether or not to execute a command by
comparing the last time a target was built with the last-modified-time of its
prerequisites? Well, it determines the last time a target was built by looking
at the last-modified-time of the target file. If the target file doesn't exist,
then it's definitely out-of-date so the command will be run.</p>

<p>But what if we accidentally create a file called <code>clean</code>? It doesn't have any
prerequisites so it will always be up-to-date and the commands will never be
run! We need a way to tell <code>make</code> that this is a special target, it isn't really
a file on disk, it's an action that should always be executed. We can do this
with a magic built-in target called <code>.PHONY</code>:</p>
<pre><code class="language-makefile">.PHONY: default build run clean
</code></pre>

<h1>Paging</h1>

<p>Up until now we did a lot of work that wasn't actually
writing kernel code. So let's review what we're up to:</p>
<ol>
<li>GRUB loaded our kernel, and started running it.</li>
<li>We're currently running in 'protected mode', a 32-bit environment.</li>
<li>But we are still using the GDT created by the GRUB boot loader</li>
</ol>
<p>Our plan now:</p>
<ol>
<li>Initialize our own GDT and switch to it.</li>
<li>Initialize a page table and switch to it.</li>
<li>Setup stack and call into main.</li>
</ol>


<h2>Paging</h2>

<p>Paging is implemented by a part of the CPU called an 'MMU', for 'memory
management unit'. The MMU will translate virtual addresses into
their respective physical addresses automatically; we can write all of our
software with virtual addresses only. The MMU does this with a data structure
called a 'page table'. As an operating system, we load up the page table with a
certain data structure, and then tell the CPU to enable paging. This is the task
ahead of us; it's required to set up paging before we transition to long mode.</p>

<p>How should we do our mapping of physical to virtual addresses? You can make
this easy, or complex, and it depends on exactly what you want your OS to
be good at. Some strategies are better than others, depending on the kinds of
programs you expect to be running. We're going to keep it simple, and use a
strategy called 'identity mapping'. This means that every virtual address will
map to a physical address of the same number. Nothing fancy.</p>

<p>Let's talk more about the page table. In 32bit mode, the page table is two
levels deep, and each page is 4096 bytes in size. What do I mean by levels?
Here are the official names:</p>

<ul>
<li>Page-Directory Table (PD)</li>
<li>Page Table (PT)</li>
</ul>


<h2>Setting up GDT</h2>

<p>To start using a new GDT we really need help from assembly language. There is a 
small window of time right after we load the GDT when the data and stack segments 
may still point to an old GDT and any memory or stack instruction will crash us. 

<p>The rest, i.e., initialization of the GDT, can be done from C. In many ways using C is 
better -- it's less error prone, more portable, and in general just feels nice. 

<p>We declare or GDT in <a href="src/main.c">main.c</a> like
<pre>
struct segdesc gdt[NSEGS] = {
    [SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0),
    [SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0),
};
</pre>

<p>In other words it's an array of <code>NSEGS</code> entries (we need only 3, one is a default 
NULL entry, one for kernel code, and one for kernel data. 

<p>Each element of the array is a segment descriptor defined in <a href="src/mmu.h">mmu.h</a> as a 
C data structure: 

<pre>
// Segment Descriptor
struct segdesc {
  uint lim_15_0 : 16;  // Low bits of segment limit
  uint base_15_0 : 16; // Low bits of segment base address
  uint base_23_16 : 8; // Middle bits of segment base address
  uint type : 4;       // Segment type (see STS_ constants)
  uint s : 1;          // 0 = system, 1 = application
  uint dpl : 2;        // Descriptor Privilege Level
  uint p : 1;          // Present
  uint lim_19_16 : 4;  // High bits of segment limit
  uint avl : 1;        // Unused (available for software use)
  uint rsv1 : 1;       // Reserved
  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
  uint g : 1;          // Granularity: limit scaled by 4K when set
  uint base_31_24 : 8; // High bits of segment base address
};
</pre>

<p>Lots of bitfileds! But if you carefully compare it with the picture 
from the Intel Software Developer Manual you will see that the layout is exactly the same. 

<p>
We also use macros to instantiate individual segment descriptor entries:

<pre>
#define SEG(_type, _base, _lim, _dpl) (struct segdesc)    \
{ .lim_15_0 = ((_lim) >> 12) & 0xffff, \
  .base_15_0 = (uint)(_base) & 0xffff, \
  .base_23_16 = ((uint)(_base) >> 16) & 0xff, \
  .type = _type, \
  .s = 1, \
  .dpl = _dpl, \
  .p = 1,       \
  .lim_19_16 = (uint)(_lim) >> 28, \
  .avl = 0, \
  .rsv1 = 0, \
  .db = 1, \
  .g = 1, \
  .base_31_24 = (uint)(_base) >> 24 }
</pre>

<p>Finally, since our goal is to load the new GDT into the GDTR register, 
we need a GDT descriptor (remember it has the size - 1 of the GDT and it's base location). 
In C we can do it like this:

<pre>
struct gdtdesc gdtdesc = { .limit = sizeof(gdt) - 1, .base =(uint) &gdt[0] };
</pre>

<p>Where the data structure itself is defined to match the definition from the Intel SDM: 

<pre>
// To force compiler to use 1 byte packaging
#pragma pack(1)
struct gdtdesc {
  ushort limit;
  uint base;
};
</pre>

<p>One interesting detail is the <code>#pragma pack(1)</code> directive that asks the compiler to avoid 
padding the data structure fields (without it the compiler will try to add another <code>ushort</code> in 
between <code>limit</code> and <code>base</code> fields). 

<p>
Now in our assembly code we're ready to reload the GDT like this:

<pre>
    lgdt [gdtdesc]
</pre>

Finally, to start using the GDT we have to perform a long jump to make sure that the CS register is 
reloaded from the new GDT. We do it by jumping to the label right below the current jump instruction/ 

<pre>
    jmp SEG_KCODE:reload_cs
reload_cs:

    ; load 0 into all data segment registers
    mov ax, SEG_KDATA
    mov ss, ax
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
</pre>

<p>Here <code>SEG_KCODE</code> and <code>SEG_KDATA</code> are defined in assembly to match the 
entries for code and data in our GDT: 

<pre> 
%define SEG_KCODE (1 << 3)
%define SEG_KDATA (2 << 3)
</pre>

<b>Your assignment is to implement the GDT switch described above</b>

<h2>Setting up the stack</h2>

Now, since we have a GDT we can move on with a page table. The page table can be 
entirely done in C. We can set up the stack and jump into main. 

<p>The stack we can define in either C or assembly (your choice, I don't see any harm 
in a simple asm definition, although arguably C is a little cleaner). 

<pre>
section .bss
align 4096

stack:
    resb 4096; Reserve this many bytes
</pre>

<p>

Then you initialize the stack like

<pre>
mov esp, stack + 4096
call main
</pre>

Just make sure that ASM knows about the <code>main</code> symbol. 

<pre>
; make sure ASM knows about main
; put this somewhere at the top of your boot.asm file
extern main
</pre>



<p>
If you choose to declare in C you can use something like:

<pre>
__attribute__((__aligned__(PGSIZE)))
char c_stack[PGSIZE];
</pre>

<p>
And then this in assembly to load it into the ESP register

<pre>
; make sure the c_stack is visible in assembly
extern c_stack

  ...

  mov esp, c_stack + 4096
</pre>


<h2>Creating the page table</h2>

<p>Now we can go with creating a page table. Again, to make it simple, we will simply 
will use C to define the page table similar to how xv6 defines the entry page directory, 
but with 4K pages. 


<pre>
// Entry 0 of the page table maps to physical page 0, entry 1 to
// physical page 1, etc.
__attribute__((__aligned__(PGSIZE)))
pte_t entry_pgtable[NPTENTRIES] = {
    0x000000 | PTE_P | PTE_W,
    0x001000 | PTE_P | PTE_W,
    0x002000 | PTE_P | PTE_W,
    0x003000 | PTE_P | PTE_W,
    ...
};

__attribute__((__aligned__(PGSIZE)))
pde_t entry_pgdir[NPDENTRIES] = {
    // Map VA's [0, 4MB) to PA's [0, 4MB)
    [0] = ((uint)entry_pgtable) + PTE_P + PTE_W,
};
</pre>

In this homework you have to map the first 2MB of virtual memory to the first 2MB of 
physical memory. Of course writing 512 entries by hand looks a bit ugly, so you are 
welcome to automate it with a loop if you like. 

<p>Inside <code>main()</code> you can add this code to first load the page table 
into the CR3 register, and then enable paging by updating the <code>CR0</code> register.

<pre>
    write_cr3((uint)&entry_pgdir);

    int cr0 = read_cr0();
    cr0 |= CR0_PG;
    write_cr0(cr0);
</pre>

<h2>Compiling main()</h2>

<p>Download the skeleton for the <a href="./src/main.c">main.c</a>, <a href="./src/console.c">console.c</a>, 
and <a href="./src/console.h">console.h</a> files. A minimal <code>main()</code> function can look something 
like this: 

<pre>
#include "console.h"

int main(void)
{
    // Initialize the page table here

    // Initialize the console
    uartinit(); 
    
    printk("Hello from C\n");
    
    return 0; 
} 
</pre>

<p>It calls the <code>uartinit()</code> function to initialize the serial line and then prints 
"Hello from C" on the serial line. 

<p>Serial ports are a legacy communications port common on IBM-PC compatible computers. Use of serial ports for connecting peripherals has largely been deprecated in favor of USB and other modern peripheral interfaces, however it is still commonly used in certain industries for interfacing with industrial hardware such as CNC machines or commercial devices such as POS terminals. Historically it was common for many dial-up modems to be connected via a computer's serial port, and the design of the underlying UART hardware itself reflects this.

<p>
Serial ports are typically controlled by UART hardware. This is the hardware chip responsible for encoding and decoding the data sent over the serial interface. Modern serial ports typically implement the RS-232 standard, and can use a variety of different connector interfaces. The DE-9 interface is the one most commonly used connector for serial ports in modern systems.

<p>
Serial ports are of particular interest to operating-system developers since they are much easier to implement drivers for than USB, and are still commonly found in many x86 systems. It is common for operating-system developers to use a system's serial ports for debugging purposes, since they do not require sophisticated hardware setups and are useful for transmitting information in the early stages of an operating-system's initialization. Many emulators such as QEMU and Bochs allow the redirection of serial output to either stdio or a file on the host computer. 

<h3> Why Use a Serial Port?</h3>

During the early stages of kernel development, you might wonder why you would bother writing a serial driver. There are several reasons why you might:

<ul>
<li>GDB debugging
    You can use the serial port to connect to a host computer, and use the GDB debugger to debug your operating system. This involves writing a stub for GDB within your OS. 
<li>Headless console
    You can operate the computer without a monitor, keyboard or mouse and instead use the serial port as a console using a protocol such as TTY or VT100. 
<li>External logging
    When the system itself is in danger of potentially crashing at times, it's nice to get debugging outputs safe to another computer before the test system triple-faults. 
<li>Networking and File transfers
    Serial ports are useful for transferring information between systems when other more traditional methods are unavailable. 
</ul>

<h2>Serial line driver</h2>

<p>To print something on the serial line we need to implement a minimal serial line driver. In this homework assignment we provide you a simple 
serial driver in <code>console.c</code>. It still makes sense for you to look over the page that describes the details of the serial line 
protocol <a href="https://wiki.osdev.org/Serial_Ports">Serial Ports @ OSDev.org</a>.

At a high level we define which I/O port serial line is connected to:

<pre>
#define COM1    0x3f8
</pre>

We then use a couple of helper functions that provide the interface to assembly 
<code>in</code> and <code>out</code> instructions. 

<pre>
static inline unsigned char inb(unsigned short port)
{
    unsigned char data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline void outb(unsigned short port, unsigned char data)
{
    asm volatile("out %0,%1" : : "a" (data), "d" (port));
}
</pre>

We then use the <code>uartinit()</code> function to initialize the serial 
line interface

<pre>
void uartinit(void)
{

  // Turn off the FIFO
  outb(COM1+2, 0);

  // 9600 baud, 8 data bits, 1 stop bit, parity off.
  outb(COM1+3, 0x80);    // Unlock divisor
  outb(COM1+0, 115200/115200);
  outb(COM1+1, 0); 
  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
  outb(COM1+4, 0);
  outb(COM1+1, 0x01);    // Enable receive interrupts.
    
  // If status is 0xFF, no serial port.
  if(inb(COM1+5) == 0xFF)
      return;
    
  uart = 1;

  // Acknowledge pre-existing interrupt conditions;
  // enable interrupts.
  inb(COM1+2);
  inb(COM1+0);
}
</pre>

The <code>uartputc()</code> displays an individual character on the screen

<pre>
void uartputc(int c)
{
  int i;

  if(!uart)
      return;

  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
      microdelay(10);

  outb(COM1+0, c);
}
</pre>

<p>
And finally the <code>printk()</code> function prints a string on the 
screen

<pre>
void printk(char *str)
{
    int i, c;

    for(i = 0; (c = str[i]) != 0; i++){
        uartputc(c);
    }
}
</pre>

<h1>Booting into C</h1>

Now we're finally ready to boot into C. If you put all the files in the correct 
places, you can run make and get "Hello from C" on the serial line. The serial line 
is configured to be recorded in the <code>serial.log</code> file. 

<pre>
make qemu
</pre>

<p>
Remember if you're using your own code, disable the <code>-curses</code> flag in the
Makefile. And finally if you want to see only the console (not the VGA) you can run

<pre>
make qemu-nox
</pre>


<h1>Debugging with GDB</h1>

Another intersting skill to learn while working on this homework is debugging kernels with GDB. To do this we will be using GDB's <i>remote debugging</i> feature and QEMU's remote GDB debugging stub. Remote debugging is a very important technique for kernel development in general: the basic idea is that the main debugger (GDB in this case) runs separately from the program being debugged (the xv6 kernel atop QEMU) - they could be on completely separate machines, in fact.

<h2>Finding and breaking at an address</h2>

For example, if you want to break at the very first instruction of your kernel you 
can use <tt>readelf</tt> tool to see where this address is (remember the kernel is the same 
ELF file that you loaded in your previous homework):
<pre>
readelf -h build/kernel.bin
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x1010f0
</pre>

In this case, the entry point is <code>0x1010f0</code>.


<p>
Now we can start QEMU with GDB and break at this address. Open two terminals, either using a terminal multiplexer like <a href="https://linuxize.com/post/getting-started-with-tmux/"> tmux </a> or  in another teminal. Run <code> make qemu-gdb </code> in the first terminal. In the other terminal, change directory, and start gdb.

<table style="width:100%; border-collapse: separate;
  border-spacing: 50px 0;">
  <tr>
    <td style="padding: 5px 0; width:50%"><pre>CADE$ make qemu-gdb




















    </pre></td>
    <td style="padding: 5px 0; width:50%">
    	<pre>
put <a href=".src/.gdbinit">.gdbinit</a> file to the path of your homework 4.
CADE$ cd &lt;path_to_hw3&gt;
CADE$ gdb
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
+ target remote localhost:1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x000000000000fff0 in ?? ()
+ symbol-file kernel
(gdb) 
</pre>
</td>
  </tr>
</table>

<p>What you see on the screen is the assembly code of the BIOS that QEMU
executes as part of the platform initialization. The BIOS starts at address
<tt>0xfff0</tt> (you can read more about it in the <a
href="https://binarydebt.wordpress.com/2018/10/06/how-does-an-x86-processor-boot/">How
Does an Intel Processor Boot?</a> blog post. You can single step through the
BIOS machine code with the <tt>si</tt> (single instruction) GDB command if you
like, but it's hard to make sense of what is going on so lets skip it for now
and get to the point when QEMU starts executing the xv6 kernel. 

<p>Set a breakpoint at the address of the entry point, e.g.  

<table style="width:100%; border-collapse: separate;
  border-spacing: 50px 0;">
  <tr>
    <td style="padding: 5px 0; width:50%"><pre>




                     <b>VGA Blank mode</b>



    </pre></td>
    <td style="padding: 5px 0; width:50%">
    	<pre>
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
.
.
.
0x000000000000fff0 in ?? ()
+ symbol-file kernel
(gdb)  br *0x001010f0 
Breakpoint 1 at 0x001010f0
</pre>
</td>
  </tr>
</table>

<!--(gdb) c Continuing.  The target
architecture is assumed to be i386 => 0x10000c:	mov    %cr4,%eax

Breakpoint 1, 0x0010000c in ?? ()
(gdb)
</pre>-->

The details of what you see may differ slightly from the above output.

<h3>Troubleshooting GDB issues</h3>
It might be possible that you get the following error on gdb. 
<pre>
circinus-1:1001-/16:40>gdb
.
.
.
warning: File "/home/aburtsev/projects/cs5460/hw3/.gdbinit" auto-loading has been 
declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load:/usr/bin/mono-gdb.py".
To enable execution of this file add
	add-auto-load-safe-path /home/aburtsev/projects/cs5460/hw3/.gdbinit
line to your configuration file "/home/aburtsev/.gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/home/aburtsev/.gdbinit".
For more information about this security protection see the
"Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:
	info "(gdb)Auto-loading safe path"
</pre>

GDB uses a file called <code>.gdbinit</code> to initialize things. We provide you with a .gdbinit <a href="src/.gdbinit">file</a> with the required setup. 
However, to allow this local <code>.gdbinit</code> file to be used, we have to add the a line to the global <code>.gdbinit</code> file. Add this line to  <code>/home/&lt;your_username&gt;/.gdbinit. </code>

<pre>add-auto-load-safe-path /home/aburtsev/projects/cs5460/hw3/.gdbinit</pre>

Try to examine the gdbinit file that we provide you. It tells gdb that the file to read symbols from while debugging is in <code> build/kernel.bin </code>. Since we are using remote-debugging, gdb and the target environment communicate a network socket. The other lines in the gdbinit set up the communication. 

<h3>Making yourself familiar with GDB</h3>

<p>This part of the homework teaches you how to use GDB. If your OS and GDB are
still running exit them. You can exit QEMU by it with <b>Ctrl-A X</b> (or if
you're running on CADE you will have to press Esc-2 to switch to the QEMU
command prompt and then type <b>quit</b>. You can exit GDB by pressing
<b>Ctrl-C</b> and then <b>Ctrl-D</b>.

<p>Start your OS and gdb again as you did before. Use two terminals: one to
start the OS in QEMU (<code>make qemu-gdb</code>) and one to start GDB (<code> gdb</code>)

<p>Now we explore the other ways of setting breakpoints. Instead of 
 <code>br *0x001010f0 </code>, you can use the name of the function or an assembly label, e.g., to set the breakpoint at the beginning of the <tt>start</tt> label you can use: 

<pre> (gdb) br start </pre>

BTW, autocomplete works inside GDB, so you can just type "s" and hit Tab.

<p>Similar you can set the breakpoint on the <tt>main()</tt> function. 

<pre>
(gdb) br main
</pre>

If you need help with GDB commands, GDB can show you a list of all commands with 

<pre>
(gdb) help all
</pre>

<p>Now since you set two breakpoints you can continue execution of the system until one of them 
gets hit. In gdb enter the "c" (continue) command to run xv6 until it hits the first breakpoint (<tt>_start</tt>). 

<pre>
(gdb) c
</pre>

<p>Now use the <tt>si</tt> (step instruction) command to single step your execution (execute it one 
machine instruction at a time). Remember that the <tt>_start</tt>
label is defined in the assembly file, <tt>entry.S</tt> to be the entry point for the kernel. 
Enter <tt>si</tt> a couple of times. Note, you don't have to enter <tt>si</tt> every time, if you just 
press "enter" the GDB will execute the last command. 

<pre>
(gdb) si
</pre>

<p>Every time you enter <tt>si</tt> it executes one machine instruction and shows you the next machine 
instruction so you know what is coming next

<pre>
(gdb) si
=> 0x10000f:	or     $0x10,%eax
0x0010000f in ?? ()
</pre>

<p>You can switch between ATT and Intel disassembly syntax with these commands: 

<pre>
(gdb) set disassembly-flavor intel
(gdb) set disassembly-flavor att
</pre>

<p>You can either continue single stepping until you reach your code or the
<tt>main()</tt> function, or you can enter "c" to continue execution until the
next breakpoint. 

<pre>
(gdb) c
Continuing.

Breakpoint 1, 0x00000000001010f0 in start ()
</pre>

<p> The moment you reach the C code, you should be able to view the C source alongside using the <tt>l</tt> (list) command. Since we compiled the kernel with the "-g" flag that includes the symbol information into the ELF file we can see the C source code that we're executing. 

<pre>
Breakpoint 2, main () at main.c:14
14	{
(gdb) l
9	{
10	    asm volatile("hlt" : : );
11	}
12	
13	int main(void)
14	{
15	    int i; 
16	    int sum = 0;
</pre>

<p>Remember that when you hit the <tt>main</tt> breakpoint GDB showed you
that you're at line 14 in the main.c file (<tt>main.c:14</tt>). You can either step into the functions with the <tt>s</tt> (step)
command (note, in contrast to the <tt>si</tt> step instruction command, this
one will execute <b>one C line at a time</b>), or step over the functions with
the <tt>n</tt> (next) command which will not enter the function, but instead
will execute it till completion. 

<p>Try stepping into one of the functions you built. Once gdb has stopped at the line where you invoke a function, type <code> s </code> for <code>step</code>. 

<pre>
(gdb) s
</pre>

<p>The whole listing of the source code seems a bit inconvenient (entering
<tt>l</tt> every time you want to see the source line is a bit annoying). GDB
provides a more conventional way of following the program execution with the
TUI mechanism. Enable it with the following GDB command

<pre>
(gdb) tui enable
</pre>

<p>Now you see the source code window and the machine instructions at the bottom. You can use the same commands to walk through your program. You can scroll the source with arrow keys, PgUp, and PgDown.  

<p>TUI can show you the state of the registers and how they are changing as you execute your code

<pre>
(gdb) tui reg general
</pre>

<p>TUI is a very cute part of GDB and hence it makes sense to read more about
various capabilities <a
href="http://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html">http://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html</a>.
For example, you can specify the assembly layout to single step through machine
instructions similar to source code: 

<pre>
(gdb) layout asm
</pre>

Or you can use them both (try it)

<pre> (gdb) layout split</pre>

Or you can look at the registers too: 

<pre> (gdb) layout regs</pre>

<p>
<a href="https://beej.us/guide/bggdb/"> Beej's Quick Guide to GDB</a> is a wonderful introduction to GDB using TUI. 
<p>

<p>
You can also print variables and data structures. For example, to see 
what's the value of the <code>gdt</code> variable you can do 

<pre>
p gdt
</pre>

If you want to see the address of the gdt variable:
<pre>
p &gdt
</pre>

Similar for the GDT descriptor

<pre>
p gdtdesc
</pre>

If you want to print it as raw memory (3 ushorts shown as hex, for example)

<pre>
x /3xh &gdtdesc
</pre>

<h1>Debugging with QEMU's built-in monitor</h1>

QEMU has a built-in monitor that can inspect and modify the machine state. To enter the monitor press <code> Alt + 2 </code>. Some of the following commands should be helpful in the monitor. 

<p> <code> info mem </code>
<pre>
QEMU 4.0.0 monitor - type 'help' for more information
(qemu) info mem
0000000000000000-0000000000400000 0000000000400000 -rw
(qemu)</pre>
This displays mapped virtual memory and permissions. The above example tells us that <code> 0x0000000000400000 </code> bytes of memory from <code> 0x0000000000000000</code> to <code>0x0000000000400000 </code> are mapped read/write.

<p>
<code> info registers </code> <p>

</pre>
This displays a full dump of the machine's internal register state. Note that GDT shows the limit and base of the GDT (this is helpful!)
</p>



<hr style="margin-top:10px">
<hr style="margin-top:10px">
<h1>Implementing the page table</h1>

<p>
Finally, <b> your assignment is to implement all the boot code that we've discussed above and in addition 
a  page table that maps the first 8MB of virtual addresses 
to the first 8MB of physical memory</b>. At the moment we discussed a page table that maps first 4MB, you need 
to define and construct a new page table once you boot into <code>main()</code>. 


<h1>Extra credit: (15% bonus)</h1>

<p>Implement a simple VGA driver, i.e., when you use the <tt>printk()</tt> it
should print on both serial line like now and on the VGA screen. 


<h1>Extra credit: (5% bonus)</h1>

<p>Boot on real hardware. I.e., try booting your code on a real desktop or
laptop by either burning a CD-ROM or a USB flash drive. Virtual machines don't count. Record a video of your
code booting.  

<h1>Extra credit: (5% bonus)</h1>

<p>Change the descriptor privilege level in the GDT to 3. Analyse (understand and explain)
what happens.




<h2>Submit your work</h2>


<p>
Submit your solution through 
Gradescope <a href="https://www.gradescope.com/courses/487491">Gradescope CS5460/6460 Operating Systems</a>. <b>Please zip all of your files and submit them. If you have done extra credit then place files required for extra credit part into separate folders extra1, extra2, extra3 or extra4.


The structure of the zip file should be the following:
<pre>
/
  - Makefile
  - console.c
  - console.h
  - main.c
  - boot.asm
  - linker.ld
  - multiboot_header.asm
  - boot/grub.cfg
  - ...                             -- any other files required to start
  - /extra1                         -- optional
    - Makefile
    - console.c
    - console.h
    - main.c
    - ...
  - /extra2                         -- optional
    - Makefile
    - console.c
    - console.h
    - main.c
    - ...
  - /extra3                         -- optional
    - Video or a textfile with link to a video (no Rick Roll please)
  - /extra4                         -- optional
    - explanation.txt
	  
</pre>

</b>
	</TD>			
	</TR>
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD COLSPAN="4">
		<DIV ID="tech">Updated: November, 2020</DIV>
	</TD>
	</TR>
	</TABLE>
</BODY>
</HTML>

