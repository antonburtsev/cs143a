<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<TITLE>143A Operating Systems</TITLE>
<LINK HREF="./css/main.css" TYPE="text/css" REL="stylesheet">
<META NAME="Description" CONTENT="143A Operating Systems">
<META NAME="Keywords" CONTENT="Anton Burtsev, Burtsev, Anton, cs143a">
<SCRIPT SRC="./scripts/image_switcher.js" LANGUAGE="JavaScript"></SCRIPT>
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
	<TABLE  ID="text" ALIGN="CENTER" WIDTH="600" BORDER="0" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD>
		<DIV ID="tech_nav">
			<A HREF="../../index.html">Home</A>
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="30" ALT="" BORDER="0"/>
		</DIV>
	</TD>
	</TR>	
	<TR>
	<TD COLSPAN="4" ALIGN="LEFT" BGCOLOR="#FFFFFF">


		<P>

<h1>Homework 4: Boot into C</h1>

<p>This assignment will teach you to build a minimal bootable code that boots
on real hardware into C. Technically, you can do this assignment on any
operating system that supports the Unix API and can run Qemu (Linux Openlab
machines, your laptop that runs Linux or Linux VM, and even MacOS, etc.).
<b>You don't need to set up xv6 for this assignment</b>, but <b>if you're running
on Openlab you'll have to install QEMU</b>, see <a href="../xv6-setup.html">QEMU 
setup instructions</a>. Submit your programs
and the shell through Gradescope (see instructions at the bottom of this page). 

<p><b>NOTE: YOU CANNOT PUBLICLY RELEASE SOLUTIONS TO THIS HOMEWORK</b>. It's ok to show 
your work to your future employer as a private Git repo, however any public release is prohibited. 


For <b>Mac / OSX</b> users: the support of 32 bit applications is deprecated in
the latest version of your system. So if you already updated your system to
MacOS Catalina or have updated your XCode then we recommend you to do the
homework at the Openlab machines.  


This assignment explains how to create a minimal x86 operating system kernel using
the Multiboot standard. In fact, it will just boot and print "Hello, world!" on
the screen, and then print "Hello from C!" on the serial line from the C
<tt>main()</tt> function. 

Most of this assignment is based on <a href="https://intermezzos.github.io/book/first-edition/multiboot-headers.html">intermezzOS project</a>.


<h2>Boot overview</h2>

When you turn on a computer, it loads the BIOS from some special flash memory.
The BIOS runs self test and initialization routines of the hardware, then it
looks for bootable devices. If it finds one, the control is transferred to its
bootloader, which is a small portion of executable code stored at the device's
beginning. The bootloader has to determine the location of the kernel image on
the device and load it into memory. It also needs to switch the CPU to the
so-called protected mode because x86 CPUs start in the very limited real mode
by default (to be compatible to programs from 1978).

We won't write a bootloader because that would be a complex project on its own
(we partially covered this in class since xv6 implements a simple boot loader 
with two files: <tt>bootasm.S</tt> and <tt>bootmain.c</tt>). Instead
we will use one of the many well-tested bootloaders out there to boot our
kernel from a CD-ROM. 

<h2>Multiboot headers</h2>

<p>Let's get going! The very first thing we're going to do is create a 'multiboot
header'. What's that, you ask? Well, to explain it, let's take a small step
back and talk about how a computer boots up.</p>

<p>One of the amazing and terrible things about the x86 architecture is that it's
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it's also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That's right, when your fancy new computer starts up, it thinks
it's an 8086 from 1976. And then, through a succession of steps, we transition
through more and more modern architectures until we end at the latest and
greatest.</p>

<p>The first mode is called 'real mode'. This is a 16 bit mode that the original
x86 chips used. The second is 'protected mode'. This 32 bit mode adds new
things on top of real mode. It's called 'protected' because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections that allow
us to exercise more control around such things as RAM. We'll talk more about
those details later.</p>

<p>The final mode is called 'long mode', and it's 64 bits. Since our OS will 
only enter 32bit mode we'll not touch 64bit 'long mode'.</p>
<!--
<blockquote>
<p><strong>By the way...</strong></p>

<p>Well, that's actually a lie: there are two. Initially, you're not in long mode,
you're in 'compatibility mode'. You see, when the industry was undergoing the
transition from 32 to 64 bits, there were two options: the first was Intel's
Itanium 64-bit architecture. It did away with all of the stuff I just told
you about. But that meant that programs had to be completely recompiled from
scratch for the new chips. Intel's big competitor, AMD, saw an opportunity
here, and released a new set of chips called amd64. These chips were backwards
compatible, and so you could run both 32 and 64 bit programs on them.
Itanium wasn't compelling enough to make the pain worth it, and so Intel released
new chips that were compatible with amd64. The resulting architecture was then
called x86_64, the one we're using today. The moral of the story? Intel tried
to save you from all of the stuff we're about to do, but they failed. So
we have to do it.</p>
</blockquote>

-->

<p>So that's the task ahead of us: make the jump up the ladder and get to
32bit mode. We can do it! Let's talk more details.</p>

<h2>Firmware and the BIOS</h2>

<p>So let's begin by turning the power to our computer on.</p>

<p>When we press the power button, a bunch of low-level initialization protocols 
are executed: Management Engine, BIOS, etc.</p>

<p>With the BIOS we're already in the land of software, but unlike software that
you may be used to writing, the BIOS comes bundled with its computer and is located in
<em>r</em>ead-<em>o</em>nly <em>m</em>emory (ROM). 

<p>One of the first things the BIOS does is run a 'POST' or <em>p</em>ower-<em>o</em>n <em>s</em>elf-<em>t</em>est
which checks for the availability and integrity of all the pieces of hardware that
the computer needs including the BIOS itself, CPU registers, RAM, etc. If you've
ever heard a computer beeping at you as it boots up, that's the POST reporting
its findings.</p>

<p>Assuming no problems are found, the BIOS starts the real booting process.</p>

<blockquote>
<p><strong>By the way...</strong></p>

<p>For a while now most commercial computer manufacturers have hidden their BIOS
booting process behind some sort of splash screen. It's usually possible to see the
BIOS' logs by pressing some collection of keys when your computer is starting up.</p>

<p>The BIOS also has a menu where you can see information about the computer
like CPU and memory specs and all the hardware the BIOS detected like hard drives
and CD and DVD drives. Typically this menu is accessed by pressing some other
weird collection of keyboard keys while the computer is attempting to boot.</p>
</blockquote>

<p>The BIOS automatically finds a 'bootable drive' by looking in certain
pre-determined places like the computer's hard drive and CD and DVD drives.
A drive is 'bootable' if it contains software that can finish the booting
process. In the BIOS menu you can usually change in what order the BIOS looks
for bootable drives or tell it to boot from a specific drive.</p>

<p>The BIOS knows it's found a bootable drive by looking at the first few kilobytes
of the drive and looking for some magical numbers set in that drive's
memory. This won't be the last time some magical numbers or hacky sounding things
are used on our way to building an OS. Such is life at such a low level...</p>

<p>When the BIOS has found its bootable drive, it loads part of the drive into
memory and transfers execution to it. With this process, we move away from what
comes dictated by the computer manufacturer and move ever closer to getting our
OS running.</p>

<h2>Bootloaders</h2>

<p>The part of our bootable drive that gets executed is called a 'bootloader',
since it loads things at boot time. The bootloader's job is to take our kernel,
put it into memory, and then transition control to it.</p>

<p>Some people start their operating systems journey by writing a bootloader. For example, 
in class we started by looking at the xv6 bootloader that is loaded by the BIOS at the 
<tt>0x7c00</tt> address. In this assignment we will not be doing that. 

<p>In the interest of actually getting around to implementing a kernel, instead, we'll
use an existing bootloader: GRUB.</p>

<h2>GRUB and Multiboot</h2>

<p>GRUB stands for '<em>gr</em>and <em>u</em>nified <em>b</em>ootloader', and it's a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>

<p>The way that we do this is through a 'header'. We'll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>

<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don't even need to know
anything about all of that old stuff. If you're curious about the kinds of
things you would have needed to know, put "A20 line" into your favorite search
engine, and get ready to cry yourself to sleep.</p>

<h2>Writing our own Multiboot header</h2>

<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It's code time for real! You can download the entire folder 
that contains skeletons for the homework files <a href="./src">here</a> or 
save it file by file. Inside your homework folder there is a
file called <code>multiboot_header.asm</code>. Open it in your favorite editor.
I use <code>vim</code>, but you should feel free to use anything you'd like.</p>

<pre>
$ vim multiboot_header.asm
</pre>

This is a <code>.asm</code> file, which is short for 'assembly'. That's right, we're
going to write some assembly code here. Don't worry! It's not super hard.</p>

<h3>An aside about assembly</h3>

<p>Have you ever watched Rich Hickey's talk "Simple vs. Easy"? It's a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms.</p>

<p>Assembly coding is simple, but that doesn't mean that it's easy. We'll be doing
a little bit of assembly programming to build our operating system, but we
don't need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You've got this. A good manual on NASM assembler 
is <a href="https://nasm.us/doc/nasmdoc3.html">here</a>.</p>

<h3>The Magic Number</h3>

<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here's the
first line:</p>

<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>

<p>Ugh! Gibberish! Let's start with the semicolon (<code>;</code>). It's a comment, that
lasts until the end of the line. This particular comment says 'magic number'.
As we said, you'll be seeing a lot of magic numbers in your operating system work.
The idea of a magic number is that it's completely and utterly arbitrary. It
doesn't mean anything. It's just magic. The very first thing that the multiboot
specification requires is that we have the magic number <code>0xe85250d6</code> right
at the start.</p>

<blockquote>
<p><strong>By the way...</strong></p>
<p>Wondering how a number can have letters inside of it? <code>0xe85250d6</code> is written in
hexadecimal notation. Hexadecimal is an example of a &quot;numeral system&quot; which is a
fancy term for a system for conveying numbers. The numeral system you're probably most
familiar with is the decimal system which conveys numbers using a combination of the
symbols <code>0</code> - <code>9</code>. Hexadecimal on the other hand uses a combination of 16 symbols:
<code>0</code> - <code>9</code> and <code>a</code> - <code>f</code>. Along with its fellow numeral system, binary, hexadecimal
is used <em>a lot</em> in low level programming. In order to tell if a number is written
in hexadecimal, you may be tempted to look for the use of letters in the number,
but a more surefire way is to look for a leading <code>0x</code>. While <code>100</code> isn't a hexadecimal
number, <code>0x100</code> is.</p>
</blockquote>

<p>What's the value in having an arbitrary number there? Well, it's a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn't have the magic number,
something has gone wrong, and we can throw an error.</p>

<p>I have no idea why it's <code>0xe85250d6</code>, and I don't need to care. It just is.</p>

<p>Finally, the <code>dd</code>. It's short for 'define double word'. It declares that we're
going to stick some 32-bit data at this location. Remember, when x86 first started,
it was a 16-bit architecture set. That meant that the amount of data that could be
held in a CPU register (or one 'word' as it's commonly known) was 16 bits.
To transition to a 32-bit architecture without losing backwards compatibility,
x86 got the concept of a 'double word' or double 16 bits.</p>

<h3>The mode code</a></h3>

<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>

<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>


<h3>Header length</h3>

<p>The next thing that's required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there's two reasons why
we're not doing that:</p>

<ol>
<li>Computers should do math, not people.</li>

<li>We're going to add more stuff, and we'd have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>

<p>Here's what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>

<p>You don't have to align the comments if you don't want to. I usually don't, but
it looks nice and after we're done with this file, we're not going to mess with
it again, so we won't be constantly re-aligning them in the future.</p>

<p>The <code>header_start:</code> and <code>header_end:</code> things are called 'labels'. Labels let
us use a name to refer to a particular part of our code. Labels also refer to the
memory occupied by the data and code which directly follows it. So in our code above
the label <code>header_start</code> points directly to the memory at the very beginning of our
magic number and thus to the very beginning of our header.</p>

<p>Our third <code>dd</code> line uses those two labels to do some math: the header length is
the value of <code>header_end</code> minus the value of <code>header_start</code>. Because <code>header_start</code>
and <code>header_end</code> are just the addresses of places in memory, we can simply subtract
to get the distance between those two addresses. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>

<p>You'll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it's a pretty flexible format.</p>

<h3>The Checksum</h3>

<p>The fourth field multiboot requires is a 'checksum'. The idea is that we sum up
some numbers, and then use that number to check that they're all what we
expected things to be. It's similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>

<p>Here's the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>

<p>Again, we'll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>

<blockquote>
<p><strong>By the way...</strong></p>

<p>You might wonder why we're subtracting these values from 0x100000000. To answer this we can look at what <a href="http://nongnu.askapache.com/grub/phcoder/multiboot.pdf">the multiboot spec</a> says about the checksum value in the header:</p>
<blockquote>

<p>The field <code>checksum</code> is a 32-bit <a href="http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">unsigned value</a> which, when added to the other magic fields (i.e. <code>magic</code>, <code>architecture</code> and <code>header_length</code>), must have a 32-bit unsigned sum of zero.</p>
</blockquote>

<p>In other words:</p>
<p><code>checksum</code> + <code>magic_number</code> + <code>architecture</code> + <code>header_length</code> = 0</p>

<p>We could try and &quot;solve for&quot; <code>checksum</code> like so:</p>

<p><code>checksum</code> =  -(<code>magic_number</code> + <code>architecture</code> + <code>header_length</code>)</p>

<p>But here's where it gets weird. Computers don't have an innate concept of negative numbers. Normally we get around this by using &quot;signed integers&quot;, which is something we <a href="http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">cover in an appendix</a>. The point is we have an unsigned integer here, which means we're limited to representing only positive numbers. This means we can't literally represent -(<code>magic_number</code> + <code>architecture</code> + <code>header_length</code>) in our field.</p>

<p>If you look closely at the spec you'll notice it's strangely worded: it's asking for a value that when added to other values has a sum of zero. It's worded this way because integers have a limit to the size of numbers they can represent, and when you go over that size, the values wrap back around to zero. So 0xFFFFFFFF + 1 is.... 0x00000000. This is a hardware limitation: technically it's doing the addition correctly, giving us the 33-bit value 0x100000000, but we only have 32 bits to store things in so it can't actually tell us about that <code>1</code> in the most significant digit position! We're left with the rest of the digits, which spell out zero.</p>

<p>So what we can do here is &quot;trick&quot; the computer into giving us zero when we do the addition. Imagine for the sake of argument that <code>magic_number</code> + <code>architecture</code> + <code>header_length</code> somehow works out to be 0xFFFFFFFE. The number we'd add to that in order to make 0 would be 0x00000002. This is 0x100000000-0xFFFFFFFE, because 0x100000000 technically maps to 0 when we wrap around. So we replace 0xFFFFFFFE in our contrived example here with <code>magic_number</code> + <code>architecture</code> + <code>header_length</code>. This gives us:
<code>dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))</code></p>
</blockquote>

<h3>Ending tag</h3>

<p>After the checksum you can list a series of "tags", which is a way for the OS to
tell the bootloader to do some extra things before handing control over to the
OS, or to give the OS some extra information once started. We don't need any of
that yet, though, so we just need to include the required "end tag", which looks
like this:</p>

<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>

<p>Here we use <code>dw</code> to define a 'word' instead of just data. Remember a 'word' is 16
bits or 2 bytes on the x86_64 architecture. The multiboot specification demands
that this be exactly a word. You'll find that this is super common in operating systems:
the exact size and amount of everything matters. It's just a side-effect of
working at a low level.</p>

<h3>The Section</h3>

<p>We have one last thing to do: add a 'section' annotation. We'll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>

<p>Here's the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>

<p>That's it! Congrats, you've written a multiboot compliant header. It's a lot of
esoterica, but it's pretty straightforward once you've seen it a few times.</p>

<h2>Assembling with <code>nasm</code></h2>

<p>We can't use this file directly, we need to turn it into binary. We can use a
program called an 'assembler' to 'assemble' our assembly code into binary code.
It's very similar to using a 'compiler' to 'compile' our source code into
binary. But when it's assembly, people often use the more specific name.</p>

<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>

<pre><code class="language-bash">$ nasm -f elf32 multiboot_header.asm
</code></pre>

<p>The <code>-f elf32</code> says that we want to output a file as 32bit ELF. 

<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our 'object file', hence the <code>.o</code>. Don't let the
word 'object' confuse you. It has nothing to do with anything object oriented.
'Object files' are just binary code with some metadata in a particular format -
in our case ELF. Later, we'll take this file and use it to build our OS.</p>

You can inspect the bytes of the header with <code>hexdump</code>
<pre>
&gt; hexdump -x multiboot_header.o
0000000    50d6    e852    0000    0000    0018    0000    af12    17ad
0000010    0000    0000    0008    0000
0000018
</pre>

<h2>Summary</h2>

<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we'll write the actual code that prints "Hello world" to the screen.</p>

<h1>Hello, world!</h1>

<p>Now that we've got the headers out of the way, let's do the traditional first
program: Hello, world!</p>

<h2>The smallest kernel</h2>

<p>Our hello world will be just <em>20</em> lines of assembly code. Let's begin.

Open a file called <code>boot.asm</code> and put this in it:</p>
<pre><code class="language-x86asm">start:
    hlt
</code></pre>

<p>You've seen the <code>name:</code> form before: it's a <em>label</em>. This lets us name a line
of code. We'll call this label <code>start</code>, which is the traditional name.
GRUB will use this convention to know where to begin.</p>

<p>The <code>hlt</code> statement is our first bit of 'real' assembly. So far, we had just
been declaring data. This is actual, executable code. It's short for 'halt'.
In other words, it ends the program.</p>

<p>By giving this line a label, we can call it, sort of like a function. That's what
GRUB does: "Call the function named <code>start</code>." This function has just one
line: stop.</p>

<p>Unlike many other languages, you'll notice that there's no way to say if
this 'function' takes any arguments or not. We'll talk more about that later.</p>

<p>This code won't quite work on its own though. We need to do a little bit more
bookkeeping first. Here's the next few lines:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    hlt
</code></pre>

<p>Three new bits of information. The first:</p>
<pre><code class="language-x86asm">global start
</code></pre>

<p>This says "I'm going to define a label <code>start</code>, and I want it to be available
outside of this file." If we don't say this, GRUB won't know where to find its
definition. You can kind of think of it like a 'public' annotation in other
languages.</p>

<pre><code class="language-x86asm">section .text
</code></pre>

<p>We saw <code>section</code> briefly, but I told you we'd get to it later. The place where
we get to it is at the end of this chapter. For the moment, all you need to
know is this: code goes into a section named <code>.text</code>. Everything that comes
after the <code>section</code> line is in that section, until another <code>section</code> line.</p>
<pre><code class="language-x86asm">bits 32
</code></pre>

<p>GRUB will boot us into protected mode, aka 32-bit mode (similar to how xv6 bootloader
starts in 16bit real mode GRUB will be loaded by the BIOS and will switch into protected 32bit 
mode for us). But we have to specify directly that assembler has to generate 32bit code. 
Our Hello World will only be in 32 bits.</p>

<p>That's it! We could theoretically stop here, but instead, let's actually print
the "Hello world" text to the screen. We'll start off with an 'H':</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    hlt
</code></pre>

<p>This new line is the most complicated bit of assembly we've seen yet. There's a
lot packed into this little line.</p>

<p>The first important bit is <code>mov</code>. This is short for <code>move</code>, and it sorta looks
like this:</p>
<pre><code class="language-text">mov size place, thing
</code></pre>

<p>Oh, <code>;</code> starts a comment, remember? So the <code>; H</code> is just for us. I put this
comment here because this line prints an <code>H</code> to the screen!</p>

<p>Yup, it does. Okay, so here's why: <code>mov</code> copies <code>thing</code> into <code>place</code>. The amount
of stuff it copies is determined by <code>size</code>.</p>
<pre><code class="language-x86asm">;   size place      thing
;   |    |          |
;   V    V          V
mov word [0xb8000], 0x0248 ; H
</code></pre>

<p>"Copy one word: the number <code>0x0248</code> to ... some place.</p>

<p>The <code>place</code> looks like a number just like <code>0x0248</code>, but it has square 
brackets <code>[]</code> around it. Those brackets are special. They mean "the address 
in memory located by this number." In other words, we're copying the number 
<code>0x0248</code> into the specific memory location <code>0xb8000</code>. That's what this line does.</p>

<p>Why? Well, we're using the screen as a "memory mapped" device. Specific
positions in memory correspond to certain positions on the screen. And
the position <code>0xb8000</code> is one of those positions: the upper-left corner of the
screen.</p>

<blockquote>

<p><strong>By the way...</strong></p>

<p>&quot;Memory mapping&quot; is one of the fundamental techniques used in computer
engineering to help the CPU know how to talk to all the different physical
components of a computer. The CPU itself is just a weird little machine that
moves numbers around. It's not of any use to humans on its own: it needs to be
connected to devices like RAM, hard drives, a monitor, and a keyboard. The way
the CPU does this is through a <em>bus</em>, which is a huge pipeline of wires
connecting the CPU to every single device that might have data the CPU needs.
There's one wire per bit (since a wire can store a 1 or a 0 at any given time).
A 32-bit bus is literally 32 wires in parallel that run from the CPU to a bunch
of devices like Christmas lights around a house.</p>

<p>There are two buses that we really care about in a computer: the address bus
and the data bus. There's also a third signal that lets all the devices know
whether the CPU is requesting data from an input (reading, like from the
keyboard) or sending data to an output (writing, like to the monitor via the
video card). The address bus is for the CPU to send location information, and
the data bus is for the CPU to either write data to or read data from that
location.  Every device on the computer has a unique hard coded numerical
location, or &quot;address&quot;, literally determined by how the thing is wired up at
the factory. In the case of an input/read operation, when it sends <code>0x1001A003</code>
out on the address bus and the control signal notifies every device that it's a
read operation, it's asking, &quot;What is the data currently stored at location
<code>0x1001A003</code>?&quot; If the keyboard happens to be identified by that particular
address, and the user is pressing SPACE at this time, the keyboard says, &quot;Oh,
you're talking to me!&quot; and sends back the ASCII code <code>0x00000020</code> (for &quot;SPACE&quot;)
on the data bus.</p>

<p>What this means is that memory on a computer isn't just representing things like
RAM and your hard drive. Actual human-scale devices like the keyboard and mouse
and video card have their own memory locations too. But instead of writing a byte
to a hard drive for storage, the CPU might write a byte representing some color
and symbol to the monitor for display. There's an industry standard somewhere
that says video memory must live in the address range beginning <code>0xb8000</code>. In
order for computers to be able to work out of the box, this means that the BIOS
needs to be manufactured to assume video lives at that location, and the
motherboard (which is where the bus is all wired up) has to be manufactured to
route a <code>0xb8000</code> request to the video card.  It's kind of amazing this stuff
works at all! Anyway, &quot;memory mapped hardware&quot;, or &quot;memory mapping&quot; for short,
is the name of this technique.</p>
</blockquote>

<p>Now, we are copying <code>0x0248</code>. Why this number? Well, it's in three parts:</p>
<pre><code class="language-text"> __ background color
/  __foreground color
| /
V V
0 2 48 &lt;- letter, in ASCII
</code></pre>
<p>We'll start at the right. First, two numbers are the letter, in ASCII. <code>H</code> is
72 in ASCII, and 48 is 72 in hexadecimal: <code>(4 * 16) + 8 = 72</code>. So this will
write <code>H</code>.</p>
<p>The other two numbers are colors. There are 16 colors available, each with a
number. Here's the table:</p>
<pre><code class="language-text">| Value | Color          |
|-------|----------------|
| 0x0   | black          |
| 0x1   | blue           |
| 0x2   | green          |
| 0x3   | cyan           |
| 0x4   | red            |
| 0x5   | magenta        |
| 0x6   | brown          |
| 0x7   | gray           |
| 0x8   | dark gray      |
| 0x9   | bright blue    |
| 0xA   | bright green   |
| 0xB   | bright cyan    |
| 0xC   | bright red     |
| 0xD   | bright magenta |
| 0xE   | yellow         |
| 0xF   | white          |
</code></pre>

<p>So, <code>02</code> is a black background with a green foreground. Classic. Feel free to
change this up, use whatever combination of colors you want!</p>
<p>So this gives us a <code>H</code> in green, over black. Next letter: <code>e</code>.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    hlt
</code></pre>

<p>Lower case <code>e</code> is <code>65</code> in ASCII, at least, in hexadecimal. And <code>02</code> is our same
color code. But you'll notice that the memory location is different.</p>
<p>Okay, so we copied four hexadecimal digits into memory, right? For our <code>H</code>.
<code>0248</code>. A hexadecimal digit has sixteen values, which is 4 bits (for example, <code>0xf</code>
would be represented in bits as <code>1111</code>). Two of them make 8 bits, i.e. one byte.
Since we need half a word for the colors (<code>02</code>), and half a word for the <code>H</code> (<code>48</code>),
that's one word in total (or two bytes). Each place that the memory address points
to can hold one byte (a.k.a. 8 bits or half a word). Hence, if our first memory
position is at <code>0</code>, the second letter will start at <code>2</code>.</p>

<blockquote>

<p>You might be wondering, &quot;If we're in 32 bit mode, isn't a word 32 bits?&quot; since sometimes 'word' is used to talk about native CPU register size. Well, the 'word' keyword in the context of x86_64 assembly specifically refers to 2 bytes, or 16 bits of data.  This is for reasons of backwards compatibility.</p>
</blockquote>

<p>This math gets easier the more often you do it. And we won't be doing <em>that</em> much
more of it. There is a lot of working with hex numbers in operating systems work,
so you'll get better as we practice.</p>

<p>With this, you should be able to get the rest of Hello, World. Go ahead and try
if you want: each letter needs to bump the location twice, and you need to look
up the letter's number in hex.</p>

<p>If you don't want to bother with all that, here's the final code:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    mov word [0xb8004], 0x026c ; l
    mov word [0xb8006], 0x026c ; l
    mov word [0xb8008], 0x026f ; o
    mov word [0xb800a], 0x022c ; ,
    mov word [0xb800c], 0x0220 ;
    mov word [0xb800e], 0x0277 ; w
    mov word [0xb8010], 0x026f ; o
    mov word [0xb8012], 0x0272 ; r
    mov word [0xb8014], 0x026c ; l
    mov word [0xb8016], 0x0264 ; d
    mov word [0xb8018], 0x0221 ; !
    hlt
</code></pre>

<p>Finally, now that we've got all of the code working, we can assemble our
<code>boot.asm</code> file with <code>nasm</code>, just like we did with the <code>multiboot_header.asm</code>
file:</p>

<pre><code class="language-bash">$ nasm -f elf32 boot.asm
</code></pre>

<p>This will produce a <code>boot.o</code> file. We're almost ready to go!</p>

<h2>Linking it together</h2>

<p>Okay! So we have two different <code>.o</code> files: <code>multiboot_header.o</code> and <code>boot.o</code>.
But what we need is <em>one</em> file with both of them. Our OS doesn't have the
ability to do anything yet, let alone load itself in two parts somehow. We just
want one big binary file.</p>

<p>Enter 'linking'. If you haven't worked in a compiled language before, you
probably haven't had to deal with linking before. Linking is how we'll turn
these two files into a single output: by linking them together.</p>

<p>Open up a file called <code>linker.ld</code>and put this in it:</p>

<pre><code class="language-text">
ENTRY(start)
  
SECTIONS {
  . = 0x100000; /* Tells GRUB to load the kernel starting at the 1MB mark */

  .rodata :
  {
    /* ensure that the multiboot header is at the beginning */
    KEEP(*(.multiboot_header))
    *(.rodata .rodata.*) 
    . = ALIGN(4K);
  }

  .text :
  { 
    *(.text .text.*)
    . = ALIGN(4K);
  } 
    
  .data :
  { 
    *(.data .data.*)
    . = ALIGN(4K);
  }   
    
  .bss :
  {   
    *(.bss .bss.*)
    . = ALIGN(4K);
  }     
} 
</code></pre>

<p>This is a 'linker script'. It controls how our linker will combine these
files into the final output. Let's take it bit-by-bit:</p>

<pre><code class="language-text">ENTRY(start)
</code></pre>

<p>This sets the 'entry point' for this executable. In our case, we called our
entry point by the name people use: <code>start</code>. Remember? In <code>boot.asm</code>? Same
name here.</p>

<pre><code class="language-text">SECTIONS {
</code></pre>

<p>Okay! I've been promising you that we'd talk about sections. Everything inside
of these curly braces is a section. We annotated parts of our code with
sections earlier, and here, in this part of the linker script, we will describe
each section by name and where it goes in the resulting output.</p>

<pre><code class="language-text">
. = 0x100000;
</code></pre>

<p>This line means that we will start putting sections at the one megabyte mark.
This is the conventional place to put a kernel, at least to start. Below one
megabyte is all kinds of memory-mapped stuff. Remember the VGA stuff? It
wouldn't work if we mapped our kernel's code to that part of memory... garbage
on the screen!</p>

<pre><code class="language-text">
.boot :
</code></pre>

<p>This will create a section named <code>boot</code>. And inside of it...</p>

<pre><code class="language-text">
*(.multiboot_header)
</code></pre>

<p>... goes every section named <code>multiboot_header</code>. Remember how we defined that
section in <code>multiboot_header.asm</code>? It'll be here, at the start of the <code>boot</code>
section. That's what we need for GRUB to see it.</p>

<pre><code class="language-text">
.text :
</code></pre>

<p>Next, we define a <code>text</code> section. The <code>text</code> section is where you put code.
And inside of it...</p>

<pre><code class="language-text">
*(.text)
</code></pre>

<p>... goes every section named <code>.text</code>. See how this is working? The syntax is a
bit weird, but it's not too bad.</p>

<p>We do the same for the <code>code</code> and <code>bss</code> section. 

<p>That's it for our script! We can then use <code>ld</code> to link all of this stuff
together:</p>



<pre><code class="language-bash">$ ld -m elf_i386 -T linker.ld -o kernel.bin multiboot_header.o boot.o
</code></pre>

<p>Recall that on Mac OS X you will want to use the linker we installed to
<code>~/opt</code> and not your system linker. For example, if you did not change any of
the defaults in the installation script, this linker will be located at
<code>$HOME/opt/bin/x86_64-pc-elf-ld</code>.</p>

<p>By running this command, we do a few things:</p>
<pre><code class="language-text">
-m elf_i386
</code></pre>

ask the linker to generate the 32bit.

<pre><code class="language-text">-T linker.ld
</code></pre>

<p>This is the linker script we just made, we ask the linker to use it.</p>

<pre><code class="language-text">-o kernel.bin
</code></pre>

<p>This sets the name of our output file. In our case, that's <code>kernel.bin</code>. We'll be using
this file in the next step. It's our whole kernel!</p>

<pre><code class="language-text">multiboot_header.o boot.o
</code></pre>

<p>Finally, we pass all the <code>.o</code> files we want to link together.</p>

<p>That's it! We've now got our kernel in the <code>kernel.bin</code> file. Next, we're going to
make an ISO out of it, so that we can load it up in QEMU.</p>

<h1>Making an ISO</h1>

<p>Now that we have our <code>kernel.bin</code>, the next step is to make an ISO. Remember
compact discs? Well, by making an ISO file, we can both test our Hello World
kernel in QEMU, as well as running it on actual hardware!</p>

<p>To do this, we're going to use a GRUB tool called <code>grub2-mkrescue</code>. We have to
create a certain structure of files on disk, run the tool, and we'll get an
<code>hello.iso</code> file at the end.</p>

<p>Doing so is not very much work, but we need to make the files in the right
places. First, we need to make several directories:</p>

<pre><code class="language-bash">$ mkdir -p build/isofiles/boot/grub
</code></pre>

<p>The <code>-p</code> flag to <code>mkdir</code> will make the directory we specify, as well as any
'parent' directories, hence the <code>p</code>. In other words, this will make an
<code>build</code> directory with a <code>isofiles</code> directory inside that has <code>boot</code> inside, and finally the <code>grub</code> directory
inside of that.</p>

<p>Next, create the <code>grub.cfg</code> file inside of that <code>build/isofiles/boot/grub</code> directory,
and put this in it:</p>

<pre><code class="language-text">set timeout=0
set default=0

menuentry &quot;cs143Aos&quot; {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre>

<p>This file configures GRUB. Let's talk about the <code>menuentry</code> block first.
GRUB lets us load up multiple different operating systems, and it usually does
this by displaying a menu of OS choices to the user when the machine boots. Each
<code>menuentry</code> section corresponds to one of these. We give it a name, in this
case, <code>cs143Aos</code>, and then a little script to tell it what to do. First,
we use the <code>multiboot2</code> command to point at our kernel file. In this case,
that location is <code>/boot/kernel.bin</code>. Remember how we made a <code>boot</code> directory
inside of <code>isofiles</code>? Since we're making the ISO out of the <code>isofiles</code> directory,
everything inside of it is at the root of our ISO. Hence <code>/boot</code>.</p>

<p>Let's copy our <code>kernel.bin</code> file there now:</p>

<pre><code class="language-bash">$ cp kernel.bin build/isofiles/boot/
</code></pre>

<p>Finally, the <code>boot</code> command says "that's all the configuration we need to do,
boot it up."</p>

<p>But what about those <code>timeout</code> and <code>default</code> settings? Well, the <code>default</code> setting
controls which <code>menuentry</code> we want to be the default. The numbers start at zero,
and since we only have that one, we set it as the default. When GRUB starts, it
will wait for <code>timeout</code> seconds, and then choose the <code>default</code> option if the user
didn't pick a different one. Since we only have one option here, we just set it to
zero, so it will start up right away.</p>

<p>The final layout should look like this:</p>
<pre><code class="language-text">
build/
|---isofiles/
    |---boot
        |-- grub
        |   |-- grub.cfg
        |-- kernel.bin
</code></pre>

<p>Using <code>grub2-mkrescue</code> is easy. We run this command:</p>
<pre><code class="language-bash">$ grub2-mkrescue -o hello.iso build/isofiles
</code></pre>

<p>The <code>-o</code> flag controls the <em>o</em>utput filename, which we choose to be <code>hello.iso</code>.
And then we pass it the directory to make the ISO out of, which is the
<code>build/isofiles</code> directory we just set up.</p>
<p>After this, you have an <code>hello.iso</code> file with our teeny kernel on it. You could
burn this to a USB stick or CD and run it on an actual computer if you wanted
to! But doing so would be really annoying during development. So in the next
section, we'll use an emulator, QEMU, to run the ISO file on our development
machine.</p>

<h1>Running in QEMU</h1>

<p>Let's actually run our kernel! To do this, we'll use
<a href="http://www.qemu.org/">QEMU</a>, a full-system emulator. Using QEMU is
fairly straightfoward. If you're running on openlab you can't really connect to 
the GUI application, so we'll use <code>-curses</code>:</p>

<pre><code class="language-bash">$ qemu-system-x86_64 -curses -cdrom hello.iso
</code></pre>

<p>Type it in, hit Enter, and you should see <code>Hello, world!</code> (To exit, hit
<kbd>Esc+2</kbd> and type <code>quit</code> in the console.)</p>

<p>If you're running on your own machine you can simply run:</p>

<pre><code class="language-bash">$ qemu-system-x86_64 -cdrom hello.iso
</code></pre>

<p>You should see something what really looks like a screen of the computer with <code>Hello, world!</code> (To exit, hit
<kbd>Alt+2</kbd> and type <code>quit</code> in the console.)</p>

<p>If it shows up for you too, congrats! If not, something may have gone
wrong. Double check that you followed the examples <em>exactly</em>. Maybe
you missed something, or made a mistake while copying things down.</p>

<p>Note all of this other stuff behind the Hello World message: this part may look
different, based on your version of GRUB, and also since we didn't clear the
screen, everything from GRUB just stays as it is. We'll write a function to do
that eventually...</p>

<p>Let's talk about this command before we move on:</p>
<pre><code class="language-text">qemu-system-x86_64
</code></pre>

<p>We're running the <code>x86_64</code> variant of QEMU. While we have a 32-bit kernel 
the QEMU emulates x86 64bit architecture. And since 32bit code is part of it everything 
works.</p>

<pre><code class="language-text">-cdrom hello.iso
</code></pre>

<p>We're going to start QEMU with a CD-ROM drive, and its contents are the
<code>hello.iso</code> file we made.</p>

<p>That's it! Here's the thing, though: while that wasn't <em>too</em> complicated, it
was a lot of steps. Each time we make a change, we have to go through all these
steps over again. In the next section, we'll use Make to do all these steps for
us.</p>

<h1>Automation with Make</h1>

<p>Typing all of these commands out every time we want to build the project is
tiring and error-prone. It's nice to be able to have a single command that
builds our entire project. To do this, we'll use <code>make</code>. Download
this <a href="./src/Makefile">Makefile</a> and look over it.</p>

<p>To make this Makefile working move create boot folder in the same directory as Makefile and put previously created grub.cfg into boot folder.</p>

<p>The makefile starts by defining several variables <code>kernel</code>,
 <code>iso</code>, <code>linker_script</code>, and <code>grub_cfg</code> that
define names of the output files we want to make. <code>CFLAGS</code> is a variable 
that defines all flags to the GCC compiler. 

<pre>
kernel := build/kernel.bin
iso := build/hello.iso

linker_script := linker.ld
grub_cfg := boot/grub.cfg

CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O1 -Wall -MD -ggdb -m32 -fno-omit-frame-pointer -Werror -nostdlib

target ?= hello
</pre>

<p>We then create two lists: a list of assembly files in the folder <code>assembly_source_files</code> 
and a list of C source files, <code>c_source_files</code>. We then use the <code>patsubst</code>
command to generate another two lists that are the same file names but with <code>.o</code> as 
extension:  
<pre>
assembly_source_files := $(wildcard *.asm)
assembly_object_files := $(patsubst %.asm, build/%.o, $(assembly_source_files))
c_source_files := $(wildcard *.c)
c_object_files := $(patsubst %.c, build/%.o, $(c_source_files))
</pre>

<pre>
.PHONY: all clean qemu qemu-nox qemu-gdb qemu-gdb-nox 

all: $(kernel)

clean:
        rm -rf build

qemu: $(iso)
        qemu-system-x86_64 -cdrom $(iso) -vga std -s -serial file:serial.log

qemu-nox: $(iso)
        qemu-system-x86_64 -m 128 -cdrom $(iso) -vga std -s -no-reboot -nographic 

qemu-gdb: $(iso)
        qemu-system-x86_64 -S -m 128 -cdrom $(iso) -vga std -s -serial file:serial.log -no-reboot -no-shutdown -d int,cpu_reset 

.PHONY: qemu-gdb-nox
qemu-gdb-nox: $(iso)
        qemu-system-x86_64 -S -m 128 -cdrom $(iso) -vga std -s -serial file:serial.log -no-reboot -no-shutdown -d int,cpu_reset -nographic

iso: $(iso)
        @echo "Done"

$(iso): $(kernel) $(grub_cfg)
        @mkdir -p build/isofiles/boot/grub
        cp $(kernel) build/isofiles/boot/kernel.bin
        cp $(grub_cfg) build/isofiles/boot/grub
        grub2-mkrescue -o $(iso) build/isofiles #2> /dev/null
        @rm -r build/isofiles

$(kernel): $(c_object_files) $(assembly_object_files) $(linker_script)
        ld -m elf_i386  -T $(linker_script) -o $(kernel) $(assembly_object_files) $(c_object_files)

# compile C files
build/%.o: %.c
        @mkdir -p $(shell dirname $@)
        gcc $(CFLAGS) -c $< -o $@

# compile assembly files
build/%.o: %.asm
        @mkdir -p $(shell dirname $@)
        nasm -felf32 $< -o $@
</pre>

<p>Our default 
action is <code>all</code> (it will build the kernel by invoking the linker). Of course 
before linking the kernel, all object files have to be compiled. 

<p>Also it's nice to add targets which describe a specific actions. 
To run the kernel we add a rule</p>
<pre>
qemu: $(iso)
        qemu-system-x86_64 -cdrom $(iso) -vga std -s -serial file:serial.log
</code></pre>

<p>Finally, there's another useful common rule: <code>clean</code>. The <code>clean</code> rule should remove all
of the generated files, and allow us to do a full re-build. 

<p>Now there's just one more wrinkle. We have four targets that aren't really files
on disk, they are just actions: <code>default</code>, <code>build</code>, <code>run</code> and <code>clean</code>. Remember
we said earlier that <code>make</code> decides whether or not to execute a command by
comparing the last time a target was built with the last-modified-time of its
prerequisites? Well, it determines the last time a target was built by looking
at the last-modified-time of the target file. If the target file doesn't exist,
then it's definitely out-of-date so the command will be run.</p>

<p>But what if we accidentally create a file called <code>clean</code>? It doesn't have any
prerequisites so it will always be up-to-date and the commands will never be
run! We need a way to tell <code>make</code> that this is a special target, it isn't really
a file on disk, it's an action that should always be executed. We can do this
with a magic built-in target called <code>.PHONY</code>:</p>
<pre><code class="language-makefile">.PHONY: default build run clean
</code></pre>

<h1>Paging</h1>

<p>Up until now we did a lot of work that wasn't actually
writing kernel code. So let's review what we're up to:</p>
<ol>
<li>GRUB loaded our kernel, and started running it.</li>
<li>We're currently running in 'protected mode', a 32-bit environment.</li>
<li>We want to enable paging.</li>
<li>We want to create a stack and jump into <code>main</code>.</li>
</ol>
<p>We're on step three. More specifically, here's what we have to do:</p>
<ol>
<li>Set up something called 'paging'.</li>
<li>Set up something called a 'GDT'.</li>
<li>Call into main.</li>
</ol>


<h2>Paging</h2>

<p>Paging is actually implemented by a part of the CPU called an 'MMU', for 'memory
management unit'. The MMU will translate virtual addresses into
their respective physical addresses automatically; we can write all of our
software with virtual addresses only. The MMU does this with a data structure
called a 'page table'. As an operating system, we load up the page table with a
certain data structure, and then tell the CPU to enable paging. This is the task
ahead of us; it's required to set up paging before we transition to long mode.</p>

<p>How should we do our mapping of physical to virtual addresses? You can make
this easy, or complex, and it depends on exactly what you want your OS to
be good at. Some strategies are better than others, depending on the kinds of
programs you expect to be running. We're going to keep it simple, and use a
strategy called 'identity mapping'. This means that every virtual address will
map to a physical address of the same number. Nothing fancy.</p>

<p>Let's talk more about the page table. In 32bit mode, the page table is two
levels deep, and each page is 4096 bytes in size. What do I mean by levels?
Here are the official names:</p>

<ul>
<li>Page-Directory Table (PD)</li>
<li>Page Table (PT)</li>
</ul>

<h2>Creating the page table</h2>

<p>So here's the strategy: create a single entry of each of these tables, then
point them at each other in the correct way, then tell the CPU that paging
should be enabled.</p>

<h3>Creating page table entries</h3>

<p>To create space for these page table entries, open up <code>boot.asm</code> and add these
lines at the bottom:</p>
<pre><code class="language-x86asm">section .bss

align 4096

pt_table:
    resb 4096
ptd_table:
    resb 4096
</code></pre>

<p>We introduce a new section, 'bss'. It stands for 'block started by symbol', and
was introduced in the 1950s. The name doesn't make much sense anymore, but the
reason we use it is because of its behavior: entries in the bss section are
automatically set to zero by the linker. This is useful, as we only want certain
bits set to 1, and most of them set to zero.</p>

<p>The <code>resb</code> directive reserves bytes; we want to reserve space for each entry.</p>

<p>The <code>align</code> directive makes sure that we've aligned our tables properly. We
haven't talked much about alignment yet: the idea is that the addresses here
will be set to a multiple of 4096, hence 'aligned' to 4096 byte chunks. We'll
eventually talk more about alignment and why it's important, but it doesn't
matter a ton right now.</p>

<p>After this has been added, we have a single valid entry for each level.
However, because our page four entry is all zeroes, we have no valid pages.
That's not super useful. Let's set things up properly.</p>

<h3>Pointing the entries at each other</h3>

<p>In order to do this setup, we need to write some more assembly code! Open up
<code>boot.asm</code>. You can either leave in printing code, or remove it. If you do leave
it in, add this code before it: that way, if you see your message print out, you
know it ran successfully.</p>
<pre><code class="language-x86asm">
global start

section .text
bits 32
start:
    ; map first PTD entry to PT table
    mov eax, pt_table
    or eax, 0b11 ; present + writable
    mov [ptd_table], eax
</code></pre>

<p>If you recall, <code>;</code> are comments. Leaving yourself excessive comments in assembly
files is a good idea. Let's go over each of these lines:</p>
<pre><code class="language-x86asm">    mov eax, pt_table
</code></pre>

<p>This copies the contents of the first page table entry into the
<code>eax</code> register. We need to do this because of the next line:</p>
<pre><code class="language-x86asm">
    or eax, 0b11
</code></pre>

<p>We take the contents of <code>eax</code> and <code>or</code> it with <code>0b11</code>, the result is written in <code>eax</code>. </p>

Each entry in a page table
contains an address, but it also contains metadata about that page. The first
two bits are the 'present bit' and the 'writable bit'. By setting the first bit,
we say "this page is currently in memory," and by setting the second, we say
"this page is allowed to be written to." There are a number of other settings we
can change this way, but they're not important for now.</p>

<blockquote>

<p><strong>By the way...</strong></p>

<p>You might be wondering, if the entry in the page table is an address, how can
we use some of the bits of that address to store metadata without messing up
the address? Remember that we used the <code>align</code> directive to make sure that the
page tables all have addresses that are multiples of 4096. That means that the
CPU can assume that the first 12 bits of all the addresses are zero. If
they're always implicitly zero, we can use them to store metadata without
changing the address.</p>
</blockquote>

<p>Now that we have an entry set up properly, the next line is of interest:</p>
<pre>
<code class="language-x86asm">
    mov dword [ptd_table + 0], eax
</code></pre>

<p>Another <code>mov</code> instruction, but this time, copying <code>eax</code>, where we've been
setting things up, into... something in brackets. <code>[]</code> means, "I will be giving
you an address between the brackets. Please do something at the place this
address points." In other words, <code>[]</code> is like a dereference operator.</p>

<p>Now, the address we've put is kind of funny looking: <code>ptd_table + 0</code>. What's up
with that <code>+ 0</code>? It's not strictly needed: adding zero to something keeps it the
same. However, it's intended to convey to the reader that we're accessing the
zeroth entry in the page table. We're about to see some more code later where we
will do something other than add zero, and so putting it here makes our code
look more symmetric overall. If you don't like this style, you don't have to put
the zero.</p>

<p>These few lines form the core of how we're setting up these page tables. We're
going to do the same thing over again, with slight variations.</p>

<p>Here's the full thing again:</p>
<pre><code class="language-x86asm"> 
    ; map first PTD entry to PT table
    mov eax, pt_table
    or eax, 0b11 ; present + writable
    mov [ptd_table], eax
</code></pre>

<p>We have one last thing to do: set up the level two page table to have valid
references to pages. We're going to do something we haven't done yet in
assembly: write a loop!</p>
<p>Here's the basic outline of loop in assembly:</p>
<ul>
<li>Create a counter variable to track how many times we've looped</li>
<li>make a label to define where the loop starts</li>
<li>do the body of the loop</li>
<li>add one to our counter</li>
<li>check to see if our counter is equal to the number of times we want to loop</li>
<li>if it's not, jump back to the top of the loop</li>
<li>if it is, we're done</li>
</ul>

<p>It's a little more detail-oriented than loops in other languages. Usually, you
have curly braces or indentation to indicate that the body of the loop is
separate, but we don't have any of those things here. We also have to write the
code to increment the counter, and check if we're done. Lots of little fiddly
bits. But that's the nature of what we're doing!</p>

<p>Let's get to it!</p>
<pre><code class="language-x86asm"> 
    ; map each P1 entry to a 4KB page
    mov ecx, 0         ; counter variable

.map_pt_table:
    ; map ecx-th PT entry to a huge page that starts at address 4KB*ecx
    mov eax, 0x1000    ; 4KB
    mul ecx            ; start address of ecx-th page
    or eax, 0b00000011 ; present + writable
    mov [pt_table + ecx * 4], eax ; map ecx-th entry

    inc ecx            ; increase counter
    cmp ecx, 1024      ; if counter == 1024, the whole P1 table is mapped
    jne .map_pt_table  ; else map the next entry

</code></pre>

<p>In order to write a loop, we need a counter. <code>ecx</code> is the usual loop counter
register, that's what the <code>c</code> stands for: counter. We also have a comment
indicating what we're doing in this part of the code.</p>

<p>Next, we need to make a new label:</p>
<pre><code class="language-x86asm">.map_pt_table:
</code></pre>

<p>As we mentioned above, this is where we will loop back to when the loop
continues.</p>

<pre><code class="language-x86asm">    mov eax, 0x1000 
</code></pre>

<p>We're going to store 0x1000 in <code>eax</code>, or 4096 which is 4KB. 

Here's the reason: each page is 4KB in size. So in order to get the 
right memory location, we will multiply the number of the loop counter by 0x1000</p>

<p>Here's that multiplication! <code>mul</code> takes just one argument, which in this case
is our <code>ecx</code> counter, and multiplies that by <code>eax</code>, storing the result in
<code>eax</code>. This will be the location of the next page.</p>
<pre><code class="language-x86asm">    or eax, 0b00000011
</code></pre>

<p>Next up, our friend <code>or</code>. Here, we again set present and writable bits <code>0b11</code>.

<pre><code class="language-x86asm">    mov [pt_table + ecx * 4], eax
</code></pre>
<p>Just like before, we are now writing the value in <code>eax</code> to a location. But
instead of it being just <code>pt_table + 0</code>, we're adding <code>ecx * 4</code>. Remember, <code>ecx</code>
is our loop counter. Each entry is four bytes in size, so we need to multiply
the counter by four, and then add it to <code>pt_table</code>. 

<p>That's the body of the loop! Now we need to see if we need to keep looping or
not:</p>
<pre><code class="language-x86asm">    inc ecx
    cmp ecx, 1024
    jne .map_pt_table
</code></pre>

<p>The <code>inc</code> instruction increments the register it's given by one. <code>ecx</code> is our
loop counter, so we're adding to it. Then, we 'compare' with <code>cmp</code>. We're
comparing <code>ecx</code> with 1024: we want to map 1024 page entries overall. The page
table is 4096 bytes, each entry is 4 bytes, so that means there are 1024 entries.
This will give us 1024 * 4KB: four megabytes of memory. It's also why we
wrote the loop: writing out 1024 entries by hand is possible, theoretically, but
is not fun. Let's make the computer do the math for us.</p>

<p>The <code>jne</code> instruction is short for 'jump if not equal'. It checks the result of
the <code>cmp</code>, and if the comparison says 'not equal', it will jump to the label
we've defined. <code>map_pt_table</code> points to the top of the loop.</p>

<p>That's it! We've written our loop and mapped our second-level page table. Here's
the full code, all in one place:</p>
<pre><code class="language-x86asm"> 
    ; map first PTD entry to PT table
    mov eax, pt_table
    or eax, 0b11 ; present + writable
    mov [ptd_table + 0], eax

    ; map each P1 entry to a 4KB page
    mov ecx, 0         ; counter variable

.map_pt_table:
    ; map ecx-th PT entry to a huge page that starts at address 4KB*ecx
    mov eax, 0x1000    ; 4KB
    mul ecx            ; start address of ecx-th page
    or eax, 0b00000011 ; present + writable
    mov [pt_table + ecx * 4], eax ; map ecx-th entry

    inc ecx            ; increase counter
    cmp ecx, 1024      ; if counter == 1024, the whole P1 table is mapped
    jne .map_pt_table  ; else map the next entry
</code></pre>

<p>Now that we've done this, we have a valid initial page table. Time to enable paging!</p>


<h3>Enable paging</h3>

<p>Now that we have a valid page table, we need to inform the hardware about it.
Here's the steps we need to take:</p>

<ul>
<li>We have to put the address of the page table directory in a special register</li>
<li>enable paging</li>
</ul>

<p>These steps are not particularly interesting, but we have to do them.

First, let's do the first step:</p>
<pre><code class="language-x86asm">    ; move page table address to cr3
    mov eax, ptd_table
    mov cr3, eax
</code></pre>

<p>So, this might seem a bit redundant: if we put <code>ptd_table</code> into <code>eax</code>, and then
put <code>eax</code> into <code>cr3</code>, why not just put <code>ptd_table</code> into <code>cr3</code>? As it turns out,
<code>cr3</code> is a special register, called a 'control register', hence the <code>cr</code>. The
<code>cr</code> registers are special: they control how the CPU actually works. In our
case, the <code>cr3</code> register needs to hold the location of the page table.</p>
<p>Because it's a special register, it has some restrictions, and one of those is
that when you <code>mov</code> to <code>cr3</code>, it has to be from another register. So we need the
first <code>mov</code> to set <code>p4_table</code> in a register before we can set <code>cr3</code>.</p>

<p>Step one: done!</p>

<p>Finally we are all ready to enable paging!</p>
<pre><code class="language-x86asm">    ; enable paging
    mov eax, cr0
    or eax, 1 &lt;&lt; 31
    mov cr0, eax
</code></pre>
<p><code>cr0</code> is the register we need to modify. We do the usual "move to <code>eax</code>, set
some bits, move back to the register" pattern. In this case, we set bit 31.</p>

<p>Once we've set these bits, we're done! Here's the full code listing:</p>
<pre><code class="language-x86asm">    ; move page table address to cr3
    mov eax, ptd_table
    mov cr3, eax

    ; enable paging
    mov eax, cr0
    or eax, 1 &lt;&lt; 31
    mov cr0, eax
</code></pre>


<h1>Setting up a GDT</h1>

<p>The GDT is used for a
style of memory handling called 'segmentation', which is in contrast to the
paging model that we just set up. Even though we're not using segmentation,
however, we're still required to have a valid GDT. Such is life.</p>

<p>So let's set up a minimal GDT. Our GDT will have three entries:</p>
<ul>
<li>a 'zero entry'</li>
<li>a 'code segment'</li>
<li>a 'data segment'</li>
</ul>

<p>If we were going to be using the GDT for real stuff, it could have a number
of code and data segment entries. But we need at least one of each to have a
minimum viable table, so let's get to it!</p>

<h2>The Zero entry</h2>

<p>The first entry in the GDT is special: it needs to be a zero value. Add this
to the bottom of <code>boot.asm</code>:</p>

<pre><code class="language-x86asm">section .rodata
gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
    ; the GDT starts with a null 8-byte
    dd 0x0 ; 4 byte
    dd 0x0 ; 4 byte
</code></pre>

<p>We have a new section: <code>rodata</code>. This stands for 'read only data', and since
we're not going to modify our GDT, having it be read-only is a good idea.</p>

<p>Next, we have a label: <code>gdt</code>. We'll use this label later, to tell the hardware
where our GDT is located.</p>

<p>Finally, <code>dd 0</code>. This defines a  'doubleword' value, in other words, a 32-bit value.
Given that it's a zero entry, it shouldn't be too surprising that the value of
this entry is zero!</p>

<p>That's all there is to it.</p>

<h2>Setting up code and data segments</a></h2>

<p>Next, we need a code segment. Add this below the zero entry that you created above

<pre><code class="language-x86asm">

; GDT for code segment. base = 0x00000000, length = 0xfffff
; for flags, refer to os-dev.pdf document, page 36
gdt_code:
    dw 0xffff    ; segment length, bits 0-15
    dw 0x0       ; segment base, bits 0-15
    db 0x0       ; segment base, bits 16-23
    db 10011010b ; flags (8 bits)
    db 11001111b ; flags (4 bits) + segment length, bits 16-19
    db 0x0       ; segment base, bits 24-31
</code>
</pre>

<p>Here we carefully follow the layout of the segment descriptor to make 
sure that all flags are set correctly (the exact layout can be found in the 
Intel Developer's Manual, 3.4.5). It would be nice to use a human-friendly macro 
like xv6 does, but I'm not good with macros in NASM. 

<p>
Similar, we define the data segment.

<pre>
; GDT for data segment. base and length identical to code segment
; some flags changed, again, refer to os-dev.pdf
gdt_data:
    dw 0xffff
    dw 0x0
    db 0x0
    db 10010010b
    db 11001111b
    db 0x0

gdt_end:
</pre>

<p>
Finally, we have to define the GDT descriptor, the special data structure that 
defines the size of the GDT and has a pointer to it in memory. We compute the 
size as the difference between two labels: <code>gdt_end</code> and <code>gdt_start</code>. The
pointer itself is the value of the label where GDT starts, i.e., <code>gdt_start</code>. 

<pre>
; GDT descriptor
gdt_descriptor:
    dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
    dd gdt_start ; address (32 bit)
</pre>

<p>
Finally, lets define two constants for the code and data segments that we can load in registers

<pre>
; define some constants for later use
CODE_SEG equ gdt_code - gdt_start
DATA_SEG equ gdt_data - gdt_start
</pre>

<p>
Note that here since each descriptor was 8 bytes long the code segment is defined as 0x8 and 
the data segment is 0x16. This is exactly what we want since the first 3 bits of the 
segment selector (3.4.2 in the Intel SDM) are used for flags. 

<p>
Now we can add this code somewhere at the top to make sure that all segment registers 
are initialized correctly. 

<pre>
; load 0 into all data segment registers
mov ax, DATA_SEG
mov ss, ax
mov ds, ax
mov es, ax
mov fs, ax
mov gs, ax
</pre>

<h2>Load the GDT</h2>

<p>So! We're finally ready to tell the hardware about our GDT. Add this line right above 
the code that initializes the data segment registers:

</p>
<pre>
<code class="language-x86asm">
    lgdt [gdt_descriptor]
</code>
</pre>

<p>We pass <code>lgdt</code> the value of our <code>gdt_descriptor</code> label. <code>lgdt</code> stands for 'load global
descriptor table'. That's it!</p>

<p>We have all of the prerequisites done! In the next section, we will complete our
boot sequence by entering <code>main()</code>.</p>


<h1>Setting stack and calling main()</h1>

<p>Now we're one step away from calling the <code>main</code> function. We need to set up 
the stack. First, lets reserve 4096 bytes (one page) for the stack in the BSS section of 
the <code>boot.asm</code> file:

<pre>
stack_bottom:
    resb 4096 * 4 ; Reserve this many bytes
stack_top:
</pre>

Now we can load the address of the stack into the <code>esp</code> register and call the main
function:

<pre>
    mov esp, stack_top
    call main
</pre>

We need to know the assembler that main will be defined in a different object file (we'll compile 
it from <code>main.c</code>). For that we need to add this line right at the top of <code>boot.asm</code>

<pre>
extern main
</pre>

<h2>Compiling main()</h2>

<p>Download the skeleton for the <a href="./src/main.c">main.c</a>, <a href="./src/console.c">console.c</a>, 
and <a href="./src/console.h">console.h</a> files. A minimal <code>main()</code> function can look something 
like this: 

<pre>
#include "console.h"

int main(void)
{
    // Initialize the console
    uartinit(); 
    
    printk("Hello from C\n");
    
    return 0; 
} 
</pre>

<p>It calls the <code>uartinit()</code> function to initialize the serial line and then prints 
"Hello from C" on the serial line. 

<p>Serial ports are a legacy communications port common on IBM-PC compatible computers. Use of serial ports for connecting peripherals has largely been deprecated in favor of USB and other modern peripheral interfaces, however it is still commonly used in certain industries for interfacing with industrial hardware such as CNC machines or commercial devices such as POS terminals. Historically it was common for many dial-up modems to be connected via a computer's serial port, and the design of the underlying UART hardware itself reflects this.

<p>
Serial ports are typically controlled by UART hardware. This is the hardware chip responsible for encoding and decoding the data sent over the serial interface. Modern serial ports typically implement the RS-232 standard, and can use a variety of different connector interfaces. The DE-9 interface is the one most commonly used connector for serial ports in modern systems.

<p>
Serial ports are of particular interest to operating-system developers since they are much easier to implement drivers for than USB, and are still commonly found in many x86 systems. It is common for operating-system developers to use a system's serial ports for debugging purposes, since they do not require sophisticated hardware setups and are useful for transmitting information in the early stages of an operating-system's initialization. Many emulators such as QEMU and Bochs allow the redirection of serial output to either stdio or a file on the host computer. 

<h3> Why Use a Serial Port?</h3>

During the early stages of kernel development, you might wonder why you would bother writing a serial driver. There are several reasons why you might:

<ul>
<li>GDB debugging
    You can use the serial port to connect to a host computer, and use the GDB debugger to debug your operating system. This involves writing a stub for GDB within your OS. 
<li>Headless console
    You can operate the computer without a monitor, keyboard or mouse and instead use the serial port as a console using a protocol such as TTY or VT100. 
<li>External logging
    When the system itself is in danger of potentially crashing at times, it's nice to get debugging outputs safe to another computer before the test system triple-faults. 
<li>Networking and File transfers
    Serial ports are useful for transferring information between systems when other more traditional methods are unavailable. 
</ul>

<h2>Serial line driver</h2>

<p>To print something on the serial line we need to implement a minimal serial line driver. In this homework assignment we provide you a simple 
serial driver in <code>console.c</code>. It still makes sense for you to look over the page that describes the details of the serial line 
protocol <a href="https://wiki.osdev.org/Serial_Ports">Serial Ports @ OSDev.org</a>.

At a high level we define which I/O port serial line is connected to:

<pre>
#define COM1    0x3f8
</pre>

We then use a couple of helper functions that provide the interface to assembly 
<code>in</code> and <code>out</code> instructions. 

<pre>
static inline unsigned char inb(unsigned short port)
{
    unsigned char data;

    asm volatile("in %1,%0" : "=a" (data) : "d" (port));
    return data;
}

static inline void outb(unsigned short port, unsigned char data)
{
    asm volatile("out %0,%1" : : "a" (data), "d" (port));
}
</pre>

We then use the <code>uartinit()</code> function to initialize the serial 
line interface

<pre>
void uartinit(void)
{

  // Turn off the FIFO
  outb(COM1+2, 0);

  // 9600 baud, 8 data bits, 1 stop bit, parity off.
  outb(COM1+3, 0x80);    // Unlock divisor
  outb(COM1+0, 115200/115200);
  outb(COM1+1, 0); 
  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
  outb(COM1+4, 0);
  outb(COM1+1, 0x01);    // Enable receive interrupts.
    
  // If status is 0xFF, no serial port.
  if(inb(COM1+5) == 0xFF)
      return;
    
  uart = 1;

  // Acknowledge pre-existing interrupt conditions;
  // enable interrupts.
  inb(COM1+2);
  inb(COM1+0);
}
</pre>

The <code>uartputc()</code> displays an individual character on the screen

<pre>
void uartputc(int c)
{
  int i;

  if(!uart)
      return;

  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
      microdelay(10);

  outb(COM1+0, c);
}
</pre>

<p>
And finally the <code>printk()</code> function prints a string on the 
screen

<pre>
void printk(char *str)
{
    int i, c;

    for(i = 0; (c = str[i]) != 0; i++){
        uartputc(c);
    }
}
</pre>

<h1>Booting into C</h1>

Now we're finally ready to boot into C. If you put all the files in the correct 
places, you can run make and get "Hello from C" on the serial line. The serial line 
is configured to be recorded in the <code>serial.log</code> file. 

<pre>
make qemu
</pre>

<p>
Remember if you're using your own code, disable the <code>-curses</code> flag in the
Makefile. And finally if you want to see only the console (not the VGA) you can run

<pre>
make qemu-nox
</pre>


<h1>Debugging with GDB</h1>

Another intersting skill to learn while working on this homework is debugging kernels with GDB. To do this we will be using GDB's <i>remote debugging</i> feature and QEMU's remote GDB debugging stub. Remote debugging is a very important technique for kernel development in general: the basic idea is that the main debugger (GDB in this case) runs separately from the program being debugged (the xv6 kernel atop QEMU) - they could be on completely separate machines, in fact.

<h2>Finding and breaking at an address</h2>

For example, if you want to break at the very first instruction of your kernel you 
can use <tt>readelf</tt> tool to see where this address is (remember the kernel is the same 
ELF file that you loaded in your previous homework):
<pre>
readelf -h build/kernel.bin
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x1010f0
</pre>

In this case, the entry point is <code>0x1010f0</code>.


<p>
Now we can start QEMU with GDB and break at this address. Open two terminals, either using a terminal multiplexer like <a href="https://linuxize.com/post/getting-started-with-tmux/"> tmux </a> or logging in to openlab in another teminal. Run <code> make qemu-gdb </code> in the first terminal. In the other terminal, change directory, and start gdb.

<table style="width:100%; border-collapse: separate;
  border-spacing: 50px 0;">
  <tr>
    <td style="padding: 5px 0; width:50%"><pre>openlab$ make qemu-gdb




















    </pre></td>
    <td style="padding: 5px 0; width:50%">
    	<pre>
put <a href="./.gdbinit">.gdbinit</a> file to the path of your homework 4.
openlab$ cd &lt;path_to_hw4&gt;
openlab$ gdb
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word".
+ target remote localhost:1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x000000000000fff0 in ?? ()
+ symbol-file kernel
(gdb) 
</pre>
</td>
  </tr>
</table>

<p>What you see on the screen is the assembly code of the BIOS that QEMU
executes as part of the platform initialization. The BIOS starts at address
<tt>0xfff0</tt> (you can read more about it in the <a
href="https://binarydebt.wordpress.com/2018/10/06/how-does-an-x86-processor-boot/">How
Does an Intel Processor Boot?</a> blog post. You can single step through the
BIOS machine code with the <tt>si</tt> (single instruction) GDB command if you
like, but it's hard to make sense of what is going on so lets skip it for now
and get to the point when QEMU starts executing the xv6 kernel. 

<p>Set a breakpoint at the address of the entry point, e.g.  

<table style="width:100%; border-collapse: separate;
  border-spacing: 50px 0;">
  <tr>
    <td style="padding: 5px 0; width:50%"><pre>




                     <b>VGA Blank mode</b>



    </pre></td>
    <td style="padding: 5px 0; width:50%">
    	<pre>
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
.
.
.
0x000000000000fff0 in ?? ()
+ symbol-file kernel
(gdb)  br *0x001010f0 
Breakpoint 1 at 0x001010f0
</pre>
</td>
  </tr>
</table>

<!--(gdb) c Continuing.  The target
architecture is assumed to be i386 => 0x10000c:	mov    %cr4,%eax

Breakpoint 1, 0x0010000c in ?? ()
(gdb)
</pre>-->

The details of what you see may differ slightly from the above output.

<h3>Troubleshooting GDB issues</h3>
It might be possible that you get the following error on gdb. 
<pre>
circinus-1:1001-/16:40>gdb
.
.
.
warning: File "/home/aburtsev/projects/143a/hw4/.gdbinit" auto-loading has been 
declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load:/usr/bin/mono-gdb.py".
To enable execution of this file add
	add-auto-load-safe-path /home/aburtsev/projects/cs143a/hw4/.gdbinit
line to your configuration file "/home/aburtsev/.gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/home/aburtsev/.gdbinit".
For more information about this security protection see the
"Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:
	info "(gdb)Auto-loading safe path"
</pre>

GDB uses a file called <code>.gdbinit</code> to initialize things. We provide you with a .gdbinit <a href="src/.gdbinit">file</a> with the required setup. 
However, to allow this local <code>.gdbinit</code> file to be used, we have to add the a line to the global <code>.gdbinit</code> file. Add this line to  <code>/home/&lt;your_username&gt;/.gdbinit. </code>

<pre>add-auto-load-safe-path /home/aburtsev/projects/cs143a/hw4/.gdbinit</pre>

Try to examine the gdbinit file that we provide you. It tells gdb that the file to read symbols from while debugging is in <code> build/kernel.bin </code>. Since we are using remote-debugging, gdb and the target environment communicate a network socket. The other lines in the gdbinit set up the communication. 

<h3>Making yourself familiar with GDB</h3>

<p>This part of the homework teaches you how to use GDB. If your OS and GDB are
still running exit them. You can exit QEMU by it with <b>Ctrl-A X</b> (or if
you're running on openlab you will have to press Esc-2 to switch to the QEMU
command prompt and then type <b>quit</b>. You can exit GDB by pressing
<b>Ctrl-C</b> and then <b>Ctrl-D</b>.

<p>Start your OS and gdb again as you did before. Use two terminals: one to
start the OS in QEMU (<code>make qemu-gdb</code>) and one to start GDB (<code> gdb</code>)

<p>Now we explore the other ways of setting breakpoints. Instead of 
 <code>br *0x001010f0 </code>, you can use the name of the function or an assembly label, e.g., to set the breakpoint at the beginning of the <tt>start</tt> label you can use: 

<pre> (gdb) br start </pre>

BTW, autocomplete works inside GDB, so you can just type "s" and hit Tab.

<p>Similar you can set the breakpoint on the <tt>main()</tt> function. 

<pre>
(gdb) br main
</pre>

If you need help with GDB commands, GDB can show you a list of all commands with 

<pre>
(gdb) help all
</pre>

<p>Now since you set two breakpoints you can continue execution of the system until one of them 
gets hit. In gdb enter the "c" (continue) command to run xv6 until it hits the first breakpoint (<tt>_start</tt>). 

<pre>
(gdb) c
</pre>

<p>Now use the <tt>si</tt> (step instruction) command to single step your execution (execute it one 
machine instruction at a time). Remember that the <tt>_start</tt>
label is defined in the assembly file, <tt>entry.S</tt> to be the entry point for the kernel. 
Enter <tt>si</tt> a couple of times. Note, you don't have to enter <tt>si</tt> every time, if you just 
press "enter" the GDB will execute the last command. 

<pre>
(gdb) si
</pre>

<p>Every time you enter <tt>si</tt> it executes one machine instruction and shows you the next machine 
instruction so you know what is coming next

<pre>
(gdb) si
=> 0x10000f:	or     $0x10,%eax
0x0010000f in ?? ()
</pre>

<p>You can switch between ATT and Intel disassembly syntax with these commands: 

<pre>
(gdb) set disassembly-flavor intel
(gdb) set disassembly-flavor att
</pre>

<p>You can either continue single stepping until you reach your code or the
<tt>main()</tt> function, or you can enter "c" to continue execution until the
next breakpoint. 

<pre>
(gdb) c
Continuing.

Breakpoint 1, 0x00000000001010f0 in start ()
</pre>

<p> The moment you reach the C code, you should be able to view the C source alongside using the <tt>l</tt> (list) command. Since we compiled the kernel with the "-g" flag that includes the symbol information into the ELF file we can see the C source code that we're executing. 

<pre>
Breakpoint 2, main () at main.c:14
14	{
(gdb) l
9	{
10	    asm volatile("hlt" : : );
11	}
12	
13	int main(void)
14	{
15	    int i; 
16	    int sum = 0;
</pre>

<p>Remember that when you hit the <tt>main</tt> breakpoint GDB showed you
that you're at line 14 in the main.c file (<tt>main.c:14</tt>). You can either step into the functions with the <tt>s</tt> (step)
command (note, in contrast to the <tt>si</tt> step instruction command, this
one will execute <b>one C line at a time</b>), or step over the functions with
the <tt>n</tt> (next) command which will not enter the function, but instead
will execute it till completion. 

<p>Try stepping into one of the functions you built. Once gdb has stopped at the line where you invoke a function, type <code> s </code> for <code>step</code>. 

<pre>
(gdb) s
</pre>

<p>The whole listing of the source code seems a bit inconvenient (entering
<tt>l</tt> every time you want to see the source line is a bit annoying). GDB
provides a more conventional way of following the program execution with the
TUI mechanism. Enable it with the following GDB command

<pre>
(gdb) tui enable
</pre>

<p>Now you see the source code window and the machine instructions at the bottom. You can use the same commands to walk through your program. You can scroll the source with arrow keys, PgUp, and PgDown.  

<p>TUI can show you the state of the registers and how they are changing as you execute your code

<pre>
(gdb) tui reg general
</pre>

<p>TUI is a very cute part of GDB and hence it makes sense to read more about
various capabilities <a
href="http://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html">http://sourceware.org/gdb/onlinedocs/gdb/TUI-Commands.html</a>.
For example, you can specify the assembly layout to single step through machine
instructions similar to source code: 

<pre>
(gdb) layout asm
</pre>

Or you can use them both (try it)

<pre> (gdb) layout split</pre>

Or you can look at the registers too: 

<pre> (gdb) layout regs</pre>

<p>
<a href="https://beej.us/guide/bggdb/"> Beej's Quick Guide to GDB</a> is a wonderful introduction to GDB using TUI. 
<p>


<h1>Debugging with QEMU's built-in monitor</h1>

QEMU has a built-in monitor that can inspect and modify the machine state. To enter the monitor press <code> Alt + 2 </code>. Some of the following commands should be helpful in the monitor. 

<p> <code> info mem </code>
<pre>
QEMU 4.0.0 monitor - type 'help' for more information
(qemu) info mem
0000000000000000-0000000000400000 0000000000400000 -rw
(qemu)</pre>
This displays mapped virtual memory and permissions. The above example tells us that <code> 0x0000000000400000 </code> bytes of memory from <code> 0x0000000000000000</code> to <code>0x0000000000400000 </code> are mapped read/write.

<p>
<code> info registers </code> <p>

</pre>
This displays a full dump of the machine's internal register state. 
</p>

<hr style="margin-top:10px">
<hr style="margin-top:10px">
<h1>Implementing the page table</h1>

<p>
Finally, <b> your assignment is to implement  page table that maps the first 8MB of virtual addresses 
to the first 8MB of physical memory</b>. At the moment we have a page table that maps first 4MB, you need 
to define and construct a new page table once you boot into <code>main()</code>. 

<p>Once your page table is constructed use the provided <code>lcr3()</code> function 
to load it into the <tt>CR3</tt> register. Note, you have to load the physical address of the 
page table. 

<h1>Extra credit: (10% bonus)</h1>


<p>Implement support for mapping 256MBs of physical memory with 4KB pages. 


<h1>Extra credit: (10% bonus)</h1>

<p>Implement a simple VGA driver, i.e., when you use the <tt>printk()</tt> it
should print on both serial line like now and on the VGA screen. 


<h1>Extra credit: (5% bonus)</h1>

<p>Boot on real hardware. I.e., try booting your code on a real desktop or
laptop by either burning a CD-ROM or a USB flash drive. Virtual machines don't count. Record a video of your
code booting.  

<h1>Extra credit: (5% bonus)</h1>

<p>Change the descriptor privilege level in the GDT to 3. Analyse (understand and explain)
what happens.




<h2>Submit your work</h2>


<p>
Submit your solution through 
Gradescope <a href="https://www.gradescope.com/courses/320403">Gradescope CS143A Operating Systems</a>. <b>Please zip all of your files and submit them. If you have done extra credit then place files required for extra credit part into separate folders extra1, extra2, extra3 or extra4.


The structure of the zip file should be the following:
<pre>
/
  - Makefile
  - console.c
  - console.h
  - main.c
  - boot.asm
  - linker.ld
  - multiboot_header.asm
  - boot/grub.cfg
  - ...                             -- any other files required to start
  - /extra1                         -- optional
    - Makefile
    - console.c
    - console.h
    - main.c
    - ...
  - /extra2                         -- optional
    - Makefile
    - console.c
    - console.h
    - main.c
    - ...
  - /extra3                         -- optional
    - Video or a textfile with link to a video (no Rick Roll please)
  - /extra4                         -- optional
    - explanation.txt
	  
</pre>

</b>
	</TD>			
	</TR>
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD COLSPAN="4">
		<DIV ID="tech">Updated: November, 2020</DIV>
	</TD>
	</TR>
	</TABLE>
</BODY>
</HTML>

