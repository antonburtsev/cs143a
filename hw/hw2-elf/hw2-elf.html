<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<TITLE>CS5460/6450 Operating Systems</TITLE>
<LINK HREF="./css/main.css" TYPE="text/css" REL="stylesheet">
<META NAME="Description" CONTENT="Home page of Anton Burtsev.">
<META NAME="Keywords" CONTENT="Anton Burtsev, Burtsev, Anton, cs143a">
<SCRIPT SRC="./scripts/image_switcher.js" LANGUAGE="JavaScript"></SCRIPT>
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0">
	<TABLE  ID="text" ALIGN="CENTER" WIDTH="600" BORDER="0" CELLPADDING="0" CELLSPACING="0">
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD>
		<DIV ID="tech_nav">
			<A HREF="../../index.html">Home</A>
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="30" ALT="" BORDER="0"/>
		</DIV>
	</TD>
	</TR>	
	<TR>
	<TD COLSPAN="4" ALIGN="LEFT" BGCOLOR="#FFFFFF">


		<P>

<h1>Homework 2: ELF files</h1>

<p>This assignment will make you more familiar with organisation of ELF files. Technically, 
  you can do this assignment on any operating system that supports the Unix API (Linux
CADE machines, your laptop that runs Linux or Linux VM, and
even MacOS, etc.). <b>You don't need to set up xv6 for this assignment</b> 
Submit your programs and the shell through Gradescope (see instructions at
the bottom of this page). 

<p><b>NOTE: YOU CANNOT PUBLICLY RELEASE SOLUTIONS TO THIS HOMEWORK</b>. It's ok to show 
your work to your future employer as a private Git repo, however any public release is prohibited. 

For <b>Mac / OSX</b> users. The support of 32 bit applications is deprecated in the latest version of your system. So if you already updated your system to MacOS Catalina or have updated your XCode then we recommend you to do the homework at the CADE machines.

<h2>Part 1: Take a look at ELF files</h2> 

<p>Download the <a href="elf.c">elf.c</a>, and look over them. At a high level
this homework asks you to implement a simple ELF loader (you will extend the
<tt>main.c</tt> file), use it to load a simple ELF object file (the one
compiled from <tt>elf.c</tt>), and relocate it. However, before starting on
this lets make ourselves familiar with ELF files. 

<p>We provide a simple <a href="Makefile">Makefile</a> that compiles <tt>elf.o</tt> and <tt>main</tt> as 
ELF executables. Look over the makefile and then compile both files by running: 

<pre>make</pre>

Lets take a look at the ELF files we compiled. We will use the <tt>readelf</tt> tool

<pre>
$ readelf -a elf
</pre>

<p>ELF is the file format used for object files (<code>.o</code>'s), binaries, shared
libraries and core dumps in Linux.</p>

<p>It's actually pretty simple and well thought-out.</p>

<p>ELF has the same layout for all architectures, however endianness and word size
can differ; relocation types, symbol types and the like may have
platform-specific values, and of course the contained code is arch specific.</p>


<p>The ELF files are used by two tools: 1) linker and 2) loader. A linker combines multiple ELF files into an executable 
or a library and a loader loads the executable ELF file in the memory of the process. On real operating systems loading 
may require relocation (e.g., if the file is dynamically linked it has to be linked again with all the shared libraries 
it depends on). In this homework we will not do any relocation (it's too complicated), we'll simply load an ELF file in memory
and run it. 

<p>Linker and loader need two different views of the ELF file, i.e., they access it differently---the linker needs 
to know where the DATA, TEXT, BSS, and other sections are to merge them with sections from other libraries. If relocation is 
required the linker needs to know where the symbol tables and relocation information is. 

<p>The loader, however, does not need any of these details. It simply needs to know which parts of the ELF file are code (executable), 
which are data and read-only data, and where to put the BSS in the memory of a process. 

<p>Hence the ELF file provides two separate views on the data inside the ELF file: 1) a more detailed view for the linker, 
and 2) a bit more high-level view for the loader. To provide these view each ELF file contains two arrays: Section Header Table (for the linker), 
and Program Header Table (for the loader). Both tables are simply arrays of entries that contain information about each part of 
the ELF file (e.g., where the sections for the linker and section for the loader are inside the ELF file).

<p> Here is a simple figure of a typical ELF file that starts with the ELF header. The header contains pointers 
to the locations  of Section Header Table and Program Header Table within the ELF file. Then each tables have entries that point to 
the starting locations of individual sections and segments. 

<p>
<IMG SRC="./hw2-elf.png" WIDTH="550" ALT=""/> 

<p>Lets take a look at both arrays.

<h2>Linking view: Section Header Table (SHT)</h2>

<p>The Section Header Table is an array in which every entry contains a pointer to one of the sections of the ELF file. <b>It's a bit 
	annoying but the parts of the ELF file used by the linker are called "sections", and the parts used by the loader 
	are called "segments"</b> (my guess is that different CPU segments were configured in the past for each part of the program 
loaded in memory, hence the name "segments", for example, an executable CPU segment was created for the executable parts of the ELF file 
(i.e., one segment that contained all executable sections like .text, .init, etc.). 

<p>Also don't get confused: sections and segments overlap. I.e., typically multiple sections (.text, .init) are all contained in one 
executable segment. Confusing, huh? It will become clear soon. 

<p>Lets take a look at what inside the ELF file. Run this command

<pre>
readelf -a elf
</pre>


If you scroll down to the <b>Section headers</b> you will see all "sections" of the ELF file 
that the linker can use: 

<pre>
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000074 000017 00 WAX  0   0  1
  [ 2] .rel.text         REL             00000000 00025c 000010 08      7   1  4
  [ 3] .data             PROGBITS        00000018 00008c 000004 00  WA  0   0  4
  [ 4] .bss              NOBITS          0000001c 000090 000004 00  WA  0   0  4
  [ 5] .comment          PROGBITS        00000000 000090 00002b 01  MS  0   0  1
  [ 6] .shstrtab         STRTAB          00000000 0000bb 000039 00      0   0  1
  [ 7] .symtab           SYMTAB          00000000 00026c 0000d0 10      8   7  4
  [ 8] .strtab           STRTAB          00000000 00033c 000027 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</pre>

The <tt>elf.c</tt> is a simple program, but it still has <tt>.text</tt>, <code>.data</code>, <code>.bss</code>, and 
<code>.rel.text</code> (relocation) sections and a bunch of sections that contain debugging information, and a <tt> .symtab</tt> 
section that contains imported and exported symbols. 

<p>
Since <code>elf.c</code> has two global variables <code>b</code> and <code>c</code> but one is initialized to <code>0</code> the 
ELF has data and BSS sections 4 bytes each (each variable is a 4 byte integer). 

<p>
Moreover, since we linked <tt>elf.c</tt> to be a static executable, it is linked to run 
at address 0x0 (the <tt>-Ttext 0</tt> tells the linker to relocate the executable at 
linking time to work at <tt>0x0</tt>) 

<p>The symbol table contains these symbols

<pre>
Symbol table '.symtab' contains 13 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 SECTION LOCAL  DEFAULT    1
     2: 00000018     0 SECTION LOCAL  DEFAULT    3
     3: 0000001c     0 SECTION LOCAL  DEFAULT    4
     4: 00000000     0 SECTION LOCAL  DEFAULT    5
     5: 00000000     0 FILE    LOCAL  DEFAULT  ABS elf.c
     6: 00000000     0 FILE    LOCAL  DEFAULT  ABS
     7: 0000001c     4 OBJECT  GLOBAL DEFAULT    4 b
     8: 00000000    23 FUNC    GLOBAL DEFAULT    1 sum
     9: 00000018     4 OBJECT  GLOBAL DEFAULT    3 c
    10: 0000001c     0 NOTYPE  GLOBAL DEFAULT    4 __bss_start
    11: 0000001c     0 NOTYPE  GLOBAL DEFAULT    3 _edata
    12: 00000020     0 NOTYPE  GLOBAL DEFAULT    4 _end
</pre>

The <tt>sum</tt> is our function (it's <tt>FUNC</tt>, and <tt>GLOBAL</tt>), the <tt>__bss_start</tt>, <tt>_edata</tt>, and <tt>_end</tt> are 
added by the linker to mark the start and end of the BSS, TEXT, and DATA sections. 

<p>If we take a look at the <tt>main</tt> executable, the ELF file is more complicated. 

<pre>
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        00000154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            00000168 000168 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            00000188 000188 000024 00   A  0   0  4
  [ 4] .gnu.hash         GNU_HASH        000001ac 0001ac 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          000001cc 0001cc 000090 10   A  6   1  4
  [ 6] .dynstr           STRTAB          0000025c 00025c 0000b8 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          00000314 000314 000012 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         00000328 000328 000040 00   A  6   1  4
  [ 9] .rel.dyn          REL             00000368 000368 000058 08   A  5   0  4
  [10] .rel.plt          REL             000003c0 0003c0 000018 08  AI  5  22  4
  [11] .init             PROGBITS        000003d8 0003d8 000023 00  AX  0   0  4
  [12] .plt              PROGBITS        00000400 000400 000040 04  AX  0   0 16
  [13] .plt.got          PROGBITS        00000440 000440 000010 08  AX  0   0  8
  [14] .text             PROGBITS        00000450 000450 000222 00  AX  0   0 16
  [15] .fini             PROGBITS        00000674 000674 000014 00  AX  0   0  4
  [16] .rodata           PROGBITS        00000688 000688 000010 00   A  0   0  4
  [17] .eh_frame_hdr     PROGBITS        00000698 000698 000034 00   A  0   0  4
  [18] .eh_frame         PROGBITS        000006cc 0006cc 0000e0 00   A  0   0  4
  [19] .init_array       INIT_ARRAY      00001ecc 000ecc 000004 04  WA  0   0  4
  [20] .fini_array       FINI_ARRAY      00001ed0 000ed0 000004 04  WA  0   0  4
  [21] .dynamic          DYNAMIC         00001ed4 000ed4 000100 08  WA  6   0  4
  [22] .got              PROGBITS        00001fd4 000fd4 00002c 04  WA  0   0  4
  [23] .data             PROGBITS        00002000 001000 000008 00  WA  0   0  4
  [24] .bss              NOBITS          00002008 001008 000004 00  WA  0   0  1
  [25] .comment          PROGBITS        00000000 001008 00002b 01  MS  0   0  1
  [26] .debug_aranges    PROGBITS        00000000 001033 000020 00      0   0  1
  [27] .debug_info       PROGBITS        00000000 001053 000554 00      0   0  1
  [28] .debug_abbrev     PROGBITS        00000000 0015a7 000132 00      0   0  1
  [29] .debug_line       PROGBITS        00000000 0016d9 0000ee 00      0   0  1
  [30] .debug_str        PROGBITS        00000000 0017c7 0003b4 01  MS  0   0  1
  [31] .symtab           SYMTAB          00000000 001b7c 000480 10     32  48  4
  [32] .strtab           STRTAB          00000000 001ffc 00024f 00      0   0  1
  [33] .shstrtab         STRTAB          00000000 00224b 00013c 00      0   0  1
</pre>

<p>It contains all the section we've mentioned in class: <tt>.text</tt> (main code of 
the program), <tt>.data</tt> (data section for global variables), <tt>.rodata</tt> (data 
section for global read-only variables), <tt>.bss</tt> (uninitialized global variables), 
<tt>.init</tt> (init section to call the constructors that run before <tt>main()</tt>), 
<tt>.got</tt>(Global Offset Table), <tt>.plt</tt> (Procedure Linking Table for lazy linking 
of imported functions), and even the <tt>.interp</tt> (the section for the interpreter, i.e., 
the linker that links dynamically linked program before it runs, typically it's 
<tt>/lib/ld-linux.so.2</tt> on Linux systems.</p>

<h2>Execution view: Program Header Table (PHT)</h2>

<p>The Program Header Table contains information for the kernel on how to start the program. The
<code>LOAD</code> directives determinate what parts of the ELF file get mapped into program 
memory.

<p>Again, in our <tt>elf</tt> example the program header defines only two segments. And 
only one of them should be loaded by the operating system in memory to run. 

<pre>
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000074 0x00000000 0x00000000 0x0001c 0x00020 RWE 0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
</pre>

The only loadable section is linked to run at address 0x0. We can inspect the <tt>elf</tt> binary 
with the <tt>objdump</tt> tool to see what is there: 

<pre>
$ objdump -d elf

elf:     file format elf32-i386


Disassembly of section .text:

00000000 <sum>:
   0:   55                      push   ebp
   1:   89 e5                   mov    ebp,esp
   3:   8b 15 1c 00 00 00       mov    edx,DWORD PTR ds:0x1c
   9:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
   c:   01 c2                   add    edx,eax
   e:   a1 18 00 00 00          mov    eax,ds:0x18
  13:   01 d0                   add    eax,edx
  15:   5d                      pop    ebp
  16:   c3                      ret
</pre>

<p>Well, no surprises: it's the <code>sum</code> function compiled into machine code.

<h2>Putting it all together: the ELF header</h2>

<p>Neither the SHT nor the PHT have fixed positions, they can be located anywhere
in an ELF file. To find them the ELF header is used, which is located at the
very start of the file.</p>

<p>The first bytes contain the elf magic <code>"\x7fELF"</code>, followed by the class ID (32
or 64 bit ELF file), the data format ID (little endian/big endian), the machine
type, etc.</p>

<p>At the end of the ELF header are then pointers to the SHT and PHT. Specifically, 
the Section Header Table which is used by the linker starts at byte 1120 in the ELF file, 
and the Program Header Table starts at byte 52 (right after the ELF header)</p>

<pre>
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          52 (bytes into file)
  Start of section headers:          1120 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         12
  Section header string table index: 11
</pre>

<p>Finally, the entry point of this file is at address <tt>0x0</tt>. This is exactly 
what we told the linker to do --- link the program to run at address <tt>0x0</tt>. And this 
is where the <tt>sum</tt> function of the <tt>elf.c</tt> file is shown in the objdump. 

<h2>Program loading in the kernel</h2>

<p>The execution of a program starts inside the kernel, in the <tt>exec("/bin/wc",...)</tt> system call
takes a path to the executable file. The kernel reads the ELF header and the program header table
(PHT), followed by lots of sanity checks.</p>

<p>The kernel then loads the parts specified in the <code>LOAD</code> directives in the PHT
into memory. If an <code>INTERP</code> entry is present, the interpreter is loaded too.
Statically linked binaries can do without an interpreter; dynamically linked
programs always need <code>/lib/ld-linux.so</code> as interpreter because it includes some
startup code, loads shared libraries needed by the binary, and performs
relocations.</p>

<p>Finally control can be transferred to the entry point of the program or to the interpreter, if
linking is required. </p>


<p>In case of a statically linked binary that's pretty much it, however with
dynamically linked binaries a lot more magic has to go on.</p>

<p>First the dynamic linker (contained within the interpreter) looks at the
<code>.dynamic</code> section, whose address is stored in the PHT.</p>
<p>There it finds the <code>NEEDED</code> entries determining which libraries have to be
loaded before the program can be run, the <code>*REL*</code> entries giving the address of
the relocation tables, the <code>VER*</code> entries which contain symbol versioning
information, etc.</p>

<p>So the dynamic linker loads the needed libraries and performs relocations
(either directly at program startup or later, as soon as the relocated symbol
is needed, depending on the relocation type).</p>

<p>Finally control is transferred to the address given by the symbol <code>_start</code> in
the binary. Normally some gcc/glibc startup code lives there, which in the end
calls <code>main()</code>.</p>

<h1>Example: load an ELF file</h1>

<p>While ELF might look a bit intimidating, in practice the loading algorithm is trivial: 

<ol>
	<li>Read the ELF header (This <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wiki</a> page should help).
	<li>One of the ELF header fields tells you the offset of the program header table inside the file.
	<li>Read each entry of the program header table (i.e., read each program header)
	<li>Each program header has an offset and size of a specific segment inside the ELF file (e.g., 
		a executable code). You have to read it from the file and load it in memory. 

	<li>When done with all segments, jump to the entry point of the program. (Note since we don't control 
		layout of the address space at the moment, we load the sections at some random place in memory (the place 
		that is allocated for us by the <tt>mmap()</tt> function). Obviously the address of the entry point 
		should be an offset within that random area. Such loading will not work for a real ELF file, but 
		ours is simple: it's statically linked, and contains the code that can run at any location in memory. So even though 
		it's linked to run at <tt>0x0</tt> it will run anywhere where you load it. 
	
</ol>

<p>Looks manageable. We make a couple of simplifications. First we create a very simple ELF file out 
of <tt>elf.c</tt> --- it contains only one function. 

<p>The <tt>main.c</tt> <a href="./main.c">main.c</a> file implements the above. Few pointers on this file. 

<p>To load the segment in memory, we use mmap to get an executable memory from the OS. You can <tt> man mmap </tt> to read more. 

<pre>
code_va = mmap(NULL, ph.memsz, PROT_READ | PROT_WRITE | PROT_EXEC,
              MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
</pre>

where <tt>ph.memsz</tt> is the size of the segment that we currently are loading.  

<p> then we load the frist section of the program header (in practice, you need to load them all) 
 
<pre>
    fseek(fptr, ph.off, SEEK_SET);
    if(fread(code_va, ph.memsz, 1, fptr) <= 0) {
        my_printf("Error reading mem");
        exit(1);
    }
</pre>

<p> Now code_va contains the executable content of the elf, we simply case it to a function pointer, assign to <tt>sum</tt> and call it. 

<pre>
    entry = (int (*)(int, int))code_va;

    if (entry != NULL) {
        sum = entry;
        ret = sum(2);
        printf("sum:%d\n", ret);
    };
</pre>

The completed program should take the name of the elf file as first argument and return the following result: 

<pre>
$ ./main elf
sum:5
</pre>

<h1>Part 1: Explain the crash</h1>

<p><code>./main elf</code> crashed. The first part of the homework asks you to
explain the crash. Specifically, you should start the program under GDB like

<pre>gdb --args main elf</pre>

Refer to HW1 for how to set a breakpoint on main and start the program under
GDB. I recommend you to use TUI to see the source code and assembly of the
program.

<p>To switch the disassembly to the Intel syntax type

<pre>set disassembly-flavor intel</pre>

inside GDB. 

<p>To enable TUI type

<pre>layout src</pre>

for source code, or 

<pre>layout asm</pre>

for assembly. 

<p>To explain ther crash explain what assemly code is doing after you invoke
the <code>sum</code> function. Specifically, you should explain which
instruction causes the crash and why. You will submit your explanation as a
text file on gradescope. 


<h1>Part 2: Relocation</h1>

<p> Now we're finally ready to start on the actual assignment. Our goal is to
learn how to relocate a binary. In the step above we loaded the binary in
memory, but it crashes as it was linked to run at an address what is different
from the one we loaded it at. Below we will relocate <a href="elf.c">elf.c</a>
to run correctly by patching all references to the gloabal variables that need
to be relocated. 


<p>  First, of all, let's be upfront about it, the wiki page will provide you
with the code of complete solution <a href="https://wiki.osdev.org/ELF_Tutorial">
ELF Tutorial</a> so if want to cross check your code against an
existing implementation, go for it. We, however try to stitch it ourself to
gain a bit of understanding. 

<p> Relocation starts by reading a table of relocation entries (i.e., the table
contains addresses of all locations in the ELF file which need to be changed to
make sure that ELF can run at a new address). 

<p> To access the relocation table we need to first read the section header
table. The section table contains a number of entries that contain various
information used by the linker (as we discussed above). Specifically, each
entry has the following C type definition: 

<pre> 
typedef struct {
	Elf32_Word	sh_name;
	Elf32_Word	sh_type;
	Elf32_Word	sh_flags;
	Elf32_Addr	sh_addr;
	Elf32_Off	sh_offset;
	Elf32_Word	sh_size;
	Elf32_Word	sh_link;
	Elf32_Word	sh_info;
	Elf32_Word	sh_addralign;
	Elf32_Word	sh_entsize;
} Elf32_Shdr;
</pre>

The <code>sh_type</code> defines the type of the entry. The following types are
defined by the ELF standard: 

<pre>
# define SHN_UNDEF	(0x00) // Undefined/Not present
 
enum ShT_Types {
	SHT_NULL	= 0,   // Null section
	SHT_PROGBITS	= 1,   // Program information
	SHT_SYMTAB	= 2,   // Symbol table
	SHT_STRTAB	= 3,   // String table
	SHT_RELA	= 4,   // Relocation (w/ addend)
	SHT_NOBITS	= 8,   // Not present in file
	SHT_REL		= 9,   // Relocation (no addend)
};
 
enum ShT_Attributes {
	SHF_WRITE	= 0x01, // Writable section
	SHF_ALLOC	= 0x02  // Exists in memory
};
</pre>

<p>
There are actually two different kinds of relocation structures; one with an
explicit added (section type <code>SHT_RELA</code>), one without (section type <code>SHT_REL</code>).
Relocation entires in the table are continuous and the number of entries in a
given table can be found by dividing the size of the table (given by <code>sh_size</code> in
the section header) by the size of each entry (given by <code>sh_entsize</code>). Each
relocation table is specific to a single section, so a single file may have
multiple relocation tables (but all entries within a given table will be the
same relocation structure type).

<p> To relocate a file we will have to iterate through all section header entries of our ELF file 
and pick the one that has the <code>SHT_REL</code> type. 

<p> There are actually two different kinds of
relocation structures; one with an explicit added (section type <code>SHT_RELA</code>), one
without (section type <code>SHT_REL</code>). Relocation entires in the table are continuous
and the number of entries in a given table can be found by dividing the size of
the table (given by <code>sh_size</code> in the section header) by the size of each entry
(given by <code>sh_entsize</code>). 

<p>
In practice, each relocation table is specific to a single section,
so a single file may have multiple relocation tables (but all entries within a
given table will be the same relocation structure type). In our case we will only deal 
with one relocation table.

<pre>
typedef struct {
	Elf32_Addr		r_offset;
	Elf32_Word		r_info;
} Elf32_Rel;
 
typedef struct {
	Elf32_Addr		r_offset;
	Elf32_Word		r_info;
	Elf32_Sword		r_addend;
} Elf32_Rela;
</pre>

<p>
The above are the definitions for the different structure types for
relocations. 

The value stored in <code>r_info</code>, as the upper byte
designates the entry in the symbol table to which the relocation applies,
whereas the lower byte stores the type of relocation that should be applied.

<pre>
# define ELF32_R_SYM(INFO)	((INFO) >> 8)
# define ELF32_R_TYPE(INFO)	((uint8_t)(INFO))
</pre>
 
<p>
The set of macro functions above can be used to attain the
individual values; ELF32_R_SYM() provides access to the symbol index and
ELF32_R_TYPE() provides access to the relocation type.

<p>
Note, in general case, an ELF file may have multiple symbol tables, thus the index of the
section header table that refers to the symbol table to which these relocation
apply can be found in the sh_link field on this relocation table's section
header. But again we will keep it simple -- only one relocation table in our case. 

<p>
The value in <code>r_offset</code> gives the relative position of the symbol that is
being relocated, within its section.

<pre>
enum RtT_Types {
	R_386_NONE		= 0, // No relocation
	R_386_32		= 1, // Symbol + Offset
	R_386_PC32		= 2  // Symbol + Offset - Section Offset
};
</pre>

<p>
The enumeration <code>RtT_Types</code> defines the relocation type we care about
in this homework. The actual relocation step is relatively simple and can be
done with the following two macros: 

<pre>
# define DO_386_32(S, A)	((S) + (A))
# define DO_386_PC32(S, A, P)	((S) + (A) - (P))
</pre>

The first one, <code>DO_386_32</code>, adds an offset to the symbol, and the second one, 
<code>DO_386_PC32</code> adds the offset but subtracts the section offset. 


<!--
<p> 
This assignment asks you implement simple static linking step by looking into
relocation table.  Download the <a href="elf-data.c">elf-data.c</a> file.  and
<a href="Makefile"> Makefile</a> so we can take a look at the relocation table.
Note that, please put main.c elf-data.c Makefile in the same directory, you can
remove the elf.c now.
-->

<h2> Ready to relocate </h2>

For our relocatable ELF file to run correctly we need to process all relocation entries present in the file. 
At a high level our algorithm is the following: 

<ol>
  <li> Read the elf header (similar to how we do this to read the program header). 
  <li> Read the section header table. 
  <li> Iterate over all section headers finding the ones that has type <code>SHT_REL</code> (i.e., the relocation table).
  <li> Once found you iterate through all entries in the relocation table (remember it will have <code>sh_size/sh_entsize</code> entries) and they will be of type <code>Elf32_Rel</code>
  <li> For each entry perform relocation

</ol>

<p>To make sure you understand what you're doing you can use <code>readelf</code> to read the relocation table 
of the <code>elf.c</code>:

<pre>
    $ make
    $ readelf -S elf
</pre>

It should output something like

<pre>
readelf -S elf
There are 9 section headers, starting at offset 0xf4:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000074 000017 00 WAX  0   0  1
  [ 2] .rel.text         REL             00000000 00025c 000010 08      7   1  4
  [ 3] .data             PROGBITS        00000018 00008c 000004 00  WA  0   0  4
  [ 4] .bss              NOBITS          0000001c 000090 000004 00  WA  0   0  4
  [ 5] .comment          PROGBITS        00000000 000090 00002b 01  MS  0   0  1
  [ 6] .shstrtab         STRTAB          00000000 0000bb 000039 00      0   0  1
  [ 7] .symtab           SYMTAB          00000000 00026c 0000d0 10      8   7  4
  [ 8] .strtab           STRTAB          00000000 00033c 000027 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</pre>

<p>You see that there is a <code>.rel.text</code> relocation section of type <code>REL</code>. 

<p>If you read the relocation table by running

 <pre>readelf -r elf</pre>

You should get something like this: 

</p> 
<pre>

Relocation section '.rel.text' at offset 0x25c contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000005  00000701 R_386_32          0000001c   b
0000000f  00000901 R_386_32          00000018   c
</pre>

<p> There are a few thing to know, first is the offset. This offset tells you an offset in the section you are relocating you should relocate 
  Second is the info, which expands to Type and and Sym info. We don't need to know anything about Sym info in this assignment. Sym info tells you how 
  to find the value of a given symbol roughtly speaking. Our interest is the Type, which tells you how to relocate at the offset.
</p> 

<p>
  To make it more concrete, let us do some calculation, in this example, in order to load elf program correctly, we need to
</p>
`<ol>
  <li>Find .text section, which is offset at 0x74.
  <li>Within .text section, offset 0x5, which is relatively to the elf file <tt> 0x74 + 0x5 </tt>. Hint: you can <tt> hexdump -C elf</tt> and look at the value at the offset. Hopefully, this looks familiar? 
  <li>This offset contains a 32bit address, which is relative to the elf file (elf file think itself starts at 0). 
  <li>we need to change this address when we load elf program into memory base on the Type. Think about how you can change this address so the elf program can run.  
</ol>


<p>For some more details, you can look at these <a href="https://wiki.osdev.org/ELF_Tutorial">ELF tutorial</a> and <a href="https://intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/">
	Executable and Linkable Format 101 Part 3: Relocations</a>. 

<h2>Submit your work</h2>

<p>
Submit your solution through 
Gradescope <a href="https://www.gradescope.com/courses/702170">Gradescope CS5460 Operating Systems</a>. Please zip all of your files (main.c, Makefile) and submit them. 

The structure of the zip file should be the following:
<pre>
  - Makefile
  - main.c
  - explain.txt
</pre>

	</TD>			
	</TR>
	<TR>
		<TD ALIGN="LEFT" BGCOLOR="#FFFFFF"><!-- top margin --> 
			<IMG SRC="./images/spacer.gif" WIDTH="100%" HEIGHT="15" ALT="" BORDER="0"/>
		</TD>
	</TR>
	<TR>
	<TD COLSPAN="4">
		<DIV ID="tech">Updated: February, 2024</DIV>
	</TD>
	</TR>
	</TABLE>
</BODY>
</HTML>

